<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="冲击秋招, 博客制作,个人经验分享,Unity,人工智能等">
    <meta name="description" content="本站记录本人各种学习的旅途，用于巩固自我并启发后来人">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>冲击秋招 | 微笑紫瞳星</title>
    <link rel="icon" type="image/png" href="/tianjuehai/MyLogo.png">

    <link rel="stylesheet" type="text/css" href="/tianjuehai/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/tianjuehai/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/tianjuehai/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/tianjuehai/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/tianjuehai/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/tianjuehai/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/tianjuehai/css/my.css">

    <script src="/tianjuehai/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/tianjuehai/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/tianjuehai/" class="waves-effect waves-light">
                    
                    <img src="/tianjuehai/medias/MyLogo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">微笑紫瞳星</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tianjuehai/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tianjuehai/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tianjuehai/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tianjuehai/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tianjuehai/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tianjuehai/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tianjuehai/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/tianjuehai/medias/MyLogo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">微笑紫瞳星</div>
        <div class="logo-desc">
            
            本站记录本人各种学习的旅途，用于巩固自我并启发后来人
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/tianjuehai/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tianjuehai/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tianjuehai/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tianjuehai/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tianjuehai/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tianjuehai/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tianjuehai/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/tianjuehai/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">冲击秋招</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/tianjuehai/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tianjuehai/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">
                                <span class="chip bg-color">游戏开发</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/tianjuehai/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" class="post-category">
                                游戏开发
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-04-29
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-05-19
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    51.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    189 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="Lua与热更新"><a href="#Lua与热更新" class="headerlink" title="Lua与热更新"></a>Lua与热更新</h2><h3 id="打包函数"><a href="#打包函数" class="headerlink" title="打包函数"></a>打包函数</h3><pre class=" language-lua"><code class="language-lua">BuildPipeline<span class="token punctuation">.</span><span class="token function">BuildAssetBundles</span><span class="token punctuation">(</span><span class="token string">"AssetBundles"</span><span class="token punctuation">,</span> BuildAssetBundleOptions<span class="token punctuation">.</span>ChunkBasedCompression<span class="token punctuation">,</span> BuildTarget<span class="token punctuation">.</span>Android<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="打包策略和方案"><a href="#打包策略和方案" class="headerlink" title="打包策略和方案"></a>打包策略和方案</h3><ol>
<li>按文件夹打包：Bundle数量少，首次下载块，但是后期更新补丁大</li>
<li>按文件打包：Bundle数量多，首次下载较慢，更新补丁小</li>
<li>整包：完整更新资源放在项目中，下载时间长，首次更新少</li>
<li>分包：大部分热更资源放在服务器上，进入游戏后下载到热更目录，安装包下，但是首次更新下载时间久。</li>
</ol>
<h3 id="简述热更新"><a href="#简述热更新" class="headerlink" title="简述热更新"></a>简述热更新</h3><h4 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h4><p>Unity 游戏热更新包含两个方面，一个是资源的更新，一个是脚本的更新。<br>Unity 提供可以热更的方案就是 AssetsBundle（后面简称 AB）。资源、代码都可以打成 AB 包，放到服务器上，然后比对版本，进行热更。Unity3D 的热更新会涉及 3 个目录：游戏资源目录、数据目录、网络资源地址。<br>游戏资源目录：游戏的安装目录，如下所示:<br>Mac OS 或 Windows：Application.dataPath + “/StreamingAssets”;<br>IOS:Application.dataPath + “/Raw”;<br>Android: jar:file://“ + Application.dataPath + “!/assets/“</p>
<p>数据目录：由于“游戏资源目录”在 Android 和 IOS 上是只读的，不能把网上的下载的资源放到里面，所以需要建立一个“数据目录”，该目录可读可写。不同平台下，“数据目录”的地址也不同，LuaFramework 的定义如下：<br>Android 或 IOS：Application.persistentDataPath + “/LuaFramework”<br>Mac OS 或 Windows：C:/LuaFramework/<br>调试模式下：Application.dataPath + “/StreamingAssets/</p>
<p>网络资源地址：又名服务器地址，是用来存放游戏资源的网址</p>
<p>热更步骤如下：</p>
<ol>
<li>第一次开启游戏后，程序将“游戏资源目录”的内容复制到“数据目录”中。（这个步骤只会执行一次，下次再打开游戏就不复制了）。</li>
<li>游戏开启后，程序会从“网络资源地址”下载一些更新的文件到数据目录。</li>
<li>游戏过程中的资源加载，都是从“数据目录”中获取解包。</li>
</ol>
<h4 id="热更新流程"><a href="#热更新流程" class="headerlink" title="热更新流程"></a>热更新流程</h4><p>热更的基本流程分为两部分：<br><strong>导出热更资源</strong><br>（1） 打包热更资源的对应的 md5 信息（涉及到增量打包）<br>（2） 上传热更 ab 到热更服务器<br>（3） 上传版本信息到版本服务器</p>
<p><strong>游戏流程热更</strong><br>（1） 启动游戏<br>（2） 根据当前版本号，和平台号去版本服务器上检查是否有热更<br>（3） 从热更服务器上下载 MD5 文件，比对需要热更的具体文件列表<br>（4） 从热更服务器上下载需要热更的资源，解压到热更资源目录<br>（5） 游戏运行加载资源，优先到热更目录中加载，再到母包资源目录加载<br>更新注意：<br>（1） 要有下载失败重试几次机制<br>（2） 要进行超时检测<br>（3） 要记录更新日志，例如哪个资源导致了整个更新流程失败</p>
<h4 id="版本号管理"><a href="#版本号管理" class="headerlink" title="版本号管理"></a>版本号管理</h4><p>客户端版本号是 4 位来标识，假设是 X.Y.Z.W<br>X：【巨大版本号】这一位其实就是 1，没事一般不会动他，除非有太巨大的变化<br>Y：【整包更新版本号】：我们游戏一般一个月会有一个比较大的版本迭代，这种版本会走商店，每次提交 Y 值+1；<br>Z：【服务器协议版本号】，一个月度版本周期内，万一 SDK 有问题或者 C#层有发现 bug，需要更新商店，这一位会+1，这里单独留一个 Z 处理这种商店版本号，是因为不想影响 Y 值，而商店提交新包要求版本号必须有增加，buildNum 也是商店要求必须要升的；<br>W：【编译版本号\热更版本号】，每次热更都+1 。<br>【第 2 位加 1 之后，3、4 位全部清 0】</p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>基本原理：<br>table是一种特殊的容器，可以向数组一样按照索引存取，也能按照键值对存取。</p>
<pre class=" language-lua"><code class="language-lua"><span class="token keyword">local</span> mytable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">--相当于数组</span>
<span class="token keyword">local</span> mytable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">--和上面等价</span>
<span class="token keyword">local</span> mytable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">--隐式赋值会覆盖掉显式赋值</span>
<span class="token keyword">local</span> mytable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token string">"bo"</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">--支持索引存储，也支持键值对存储</span>
<span class="token function">print</span><span class="token punctuation">(</span>mytable<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--输出为nil，键值对存储不能用索引访问</span>
<span class="token function">print</span><span class="token punctuation">(</span>mytable<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">--正确访问方式</span>
mytable<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">"1001"</span> <span class="token comment" spellcheck="true">--不用事先定义，使用的时候直接赋值，类似python</span>
<span class="token comment" spellcheck="true">--我们收数据的时候只用收table一种数据类型就可以了，约定好里面有什么数据后直接取即可</span>
mytable<span class="token punctuation">.</span>userdata <span class="token operator">=</span> <span class="token punctuation">{</span>atk <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">,</span> def <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">--table可以存放很多数据类型，并且可以嵌套</span>
<span class="token keyword">function</span> mytable<span class="token punctuation">:</span><span class="token function">test</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
  <span class="token function">print</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
  <span class="token function">print</span><span class="token punctuation">(</span>mytable<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span>  <span class="token function">pairs</span><span class="token punctuation">(</span>mytable<span class="token punctuation">)</span> <span class="token keyword">do</span>  <span class="token comment" spellcheck="true">--遍历方式，输出的是索引和内容，或者键值对，忽略nil项</span>
  <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>mytable<span class="token punctuation">)</span> <span class="token keyword">do</span>  <span class="token comment" spellcheck="true">--遍历方式，输出的是索引和内容，并且不能遍历键值对，并且遍历索引时遇到nil会停止输出</span>
  <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token keyword">if</span> <span class="token function">next</span><span class="token punctuation">(</span>mytable<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">nil</span> <span class="token keyword">then</span> <span class="token comment" spellcheck="true">--next第二个参数是索引位，判断索引位的下一位，如果为空就判断第一位</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"为空"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">#</span>mytable<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--判断table长度，但注意table里面不能有nil，否则长度计算会在遇到nil的地方停止</span></code></pre>
<p>底层实现：<br>table：底层实现分数组部分和哈希表部分。数组部分，从 1 开始做整数数字索引，这可以提供紧凑且高效的随机访问；数组部分存储在 TValue *array 中，其长度 信息存储在 int sizearray 中。哈希表存储在 Node *node，哈希表的大小用 lu_byte lsizenode 表示，lsizenode 表示的是 2 的几次幂，而不是实际大小，因 为哈希表的大小一定是 2 的整数次幂。哈希冲突后，采取开放地址法，应对 hash碰撞。每个 Table 结构，最多会由三块连续内存构成：<br>(1) 一个 table 结构<br>(2) 一块存放了连续整数索引的数组<br>(3) 一块大小为 2 的整数次幂的哈希表</p>
<h3 id="string底层"><a href="#string底层" class="headerlink" title="string底层"></a>string底层</h3><p>Lua 中的字符串（string）底层实现使用了一种叫作”短字符串优化”（Short String Optimization）的策略。该策略基于以下两种情况来存储字符串：</p>
<p>短字符串：长度小于等于 40 字节的字符串会直接存储在 Lua 内部的字符串对象中，而不需要额外的内存分配。这种情况下，字符串的数据会被直接存储在字符串对象的数据字段中。</p>
<p>长字符串：长度超过 40 字节的字符串则会分配额外的内存空间来存储字符串数据。Lua 使用一个单独的内存块来存储长字符串的数据，并在字符串对象中存储指向该内存块的指针。</p>
<p>无论是短字符串还是长字符串，Lua 的字符串都是不可变的（immutable）。这意味着一旦创建了一个字符串，就不能再修改它的内容。如果需要对字符串进行修改，必须创建一个新的字符串。</p>
<p>Lua 的字符串实现具有一些优点和注意事项：</p>
<ul>
<li><p>节约内存：短字符串直接存储在字符串对象中，无需额外的内存分配，节约了内存空间。长字符串使用单独的内存块存储，可以避免字符串占用过多的 Lua 内存。</p>
</li>
<li><p>高效性能：由于字符串不可变，可以在多个 Lua 值之间共享相同的字符串对象，避免了重复的字符串复制操作，提高了性能。</p>
</li>
<li><p>注意拼接操作：由于字符串不可变，每次对字符串进行拼接操作都会创建一个新的字符串对象。如果需要频繁进行字符串拼接操作，可能会导致大量的内存分配和对象创建，影响性能。在这种情况下，可以使用 Lua 中的字符串缓冲区（如 table.concat 函数）或者考虑使用 LuaJIT 提供的 FFI 接口来进行高效的字符串拼接。</p>
</li>
</ul>
<h3 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h3><pre class=" language-lua"><code class="language-lua"><span class="token keyword">local</span> mytable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
<span class="token keyword">local</span> mymetatable <span class="token operator">=</span> <span class="token punctuation">{</span>
  __index <span class="token operator">=</span> <span class="token punctuation">{</span>b<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">"c"</span><span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
mytable <span class="token operator">=</span> <span class="token function">setmetatable</span><span class="token punctuation">(</span>mytable<span class="token punctuation">,</span> mymetatable<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--元表扩展了普通表的功能</span>
<span class="token function">getmetatable</span><span class="token punctuation">(</span>mytable<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--获取元表</span>
<span class="token function">print</span><span class="token punctuation">(</span>mytable<span class="token punctuation">.</span>c<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--table里面没有的话会查找元表中的index来调用</span>


<span class="token keyword">local</span> mymetatable <span class="token operator">=</span> <span class="token punctuation">{</span>
  __index <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span>key<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">--访问table中没有的元素调用元表中的index</span>
              <span class="token keyword">if</span> key <span class="token operator">==</span> <span class="token string">"b"</span> <span class="token keyword">then</span>
                <span class="token keyword">return</span> <span class="token string">"hello"</span>
              <span class="token keyword">else</span>
                <span class="token keyword">return</span> <span class="token keyword">nil</span>
              <span class="token keyword">end</span>
              <span class="token keyword">end</span>  <span class="token comment" spellcheck="true">--如果index是一个方法</span>
  __newindex <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span>key<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--给table和元表中没有的数组元素赋值或给一个变量赋值会执行newindex</span>
                  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"被调用"</span><span class="token punctuation">)</span>
                  <span class="token keyword">return</span> <span class="token string">"NoValue"</span>
                  <span class="token keyword">end</span>
  __call <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>mytable<span class="token punctuation">,</span> newtable<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--把元表当做方法（函数）使用的时候调用call</span>
              sum <span class="token operator">=</span> <span class="token number">0</span>
              <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">#</span>mytable <span class="token keyword">do</span> 
                sum <span class="token operator">=</span> sum <span class="token operator">+</span> mytable<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token keyword">end</span>
              <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">#</span>newtable <span class="token keyword">do</span> 
                sum <span class="token operator">=</span> sum <span class="token operator">+</span> newtable<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token keyword">end</span>
              <span class="token keyword">return</span> sum
            <span class="token keyword">end</span>
  __tostring <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>mytable<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">--想要直接输出这个表的时候调用</span>
                <span class="token keyword">return</span> <span class="token operator">#</span>mytable
                <span class="token keyword">end</span>
  __add <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>mytable<span class="token punctuation">,</span> newtable<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--两个表进行相加操作的时候调用</span>
      <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> table<span class="token punctuation">.</span><span class="token function">maxn</span><span class="token punctuation">(</span>newtable<span class="token punctuation">)</span> <span class="token keyword">do</span>
         table<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>mytable<span class="token punctuation">,</span> table<span class="token punctuation">.</span><span class="token function">maxn</span><span class="token punctuation">(</span>mytable<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>newtable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token keyword">end</span>
      <span class="token keyword">return</span> mytable
   <span class="token keyword">end</span>




<span class="token punctuation">}</span>
mytable <span class="token operator">=</span> <span class="token function">setmetatable</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> mymetatable<span class="token punctuation">)</span>
<span class="token keyword">function</span> mytable<span class="token punctuation">:</span><span class="token function">test</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
  <span class="token function">print</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token function">print</span><span class="token punctuation">(</span>mytable<span class="token punctuation">.</span>b<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--会调用index里面的方法输出hello</span>
mytable<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">10</span>    <span class="token comment" spellcheck="true">--设置没有定义的变量会触发__newindex，一般里面做一些报错提醒</span>
mytable<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span>    <span class="token comment" spellcheck="true">--已经存在的数组元素，不会触发__newindex</span>
mytable<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">666</span>  <span class="token comment" spellcheck="true">--不存在的数组元素，会触发__newindex</span>
newtable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">mytable</span><span class="token punctuation">(</span>newtable<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--调用__call</span>
<span class="token function">print</span><span class="token punctuation">(</span>mytable<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">--调用__tostring</span>
mytable <span class="token operator">=</span> mytable <span class="token operator">+</span> newtable
<span class="token function">print</span><span class="token punctuation">(</span>mytable<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">---查找和赋值不调用index和newindex函数的方法</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">rawget</span><span class="token punctuation">(</span>mytable <span class="token punctuation">,</span>mytable<span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--输出的是nil</span>
<span class="token function">rawset</span><span class="token punctuation">(</span>mytable<span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">--设置不存在的变量不会调用newIndex</span>



mytable<span class="token punctuation">:</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">--这两种调用方式等价，冒号是一个语法糖</span>
mytable<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>mytable<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span></code></pre>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>一个文件想要用另外一个文件的变量，就要用到require。但是如果我们不想每次使用都require，我们可以把lua文件定义成module，这样只需要require一次加载进来，就能在所有文件中访问这个文件的变量。<br>普通用法</p>
<pre class=" language-lua"><code class="language-lua"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"math_func"</span><span class="token punctuation">)</span>
<span class="token keyword">local</span> ret <span class="token operator">=</span> <span class="token function">math_abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
</code></pre>
<p>定义Module的方式：</p>
<pre class=" language-lua"><code class="language-lua"><span class="token function">module</span><span class="token punctuation">(</span><span class="token string">"device"</span><span class="token punctuation">,</span>package<span class="token punctuation">.</span>seeall<span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">get_device_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> "guest9527<span class="token punctuation">:</span>
<span class="token keyword">end</span></code></pre>
<pre class=" language-lua"><code class="language-lua"><span class="token keyword">local</span> name <span class="token operator">=</span> device<span class="token punctuation">.</span>get_device<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>如果我们不想把一个lua文件中的所有变量都暴露出去，我们可以在文件中定义一个table作为接口，把所有变量设为local，把想要暴露的添加到table中，然后返回即可。</p>
<pre class=" language-lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">math_abs</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span>
    <span class="token keyword">return</span> <span class="token operator">-</span>value
  <span class="token keyword">end</span>
  <span class="token keyword">return</span> value

<span class="token keyword">end</span>
<span class="token keyword">function</span> <span class="token function">math_vec_length_2</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span>
  <span class="token keyword">return</span> vec<span class="token punctuation">.</span>x <span class="token operator">*</span> vec<span class="token punctuation">.</span>x <span class="token operator">+</span> vec<span class="token punctuation">.</span>y <span class="token operator">-</span> vec<span class="token punctuation">.</span>y
<span class="token keyword">end</span>
<span class="token keyword">function</span> <span class="token function">_test_func</span><span class="token punctuation">(</span><span class="token punctuation">...</span><span class="token punctuation">)</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token keyword">local</span> list <span class="token operator">=</span> <span class="token punctuation">{</span>
  abs <span class="token operator">=</span> math_abs<span class="token punctuation">,</span>
  lenth <span class="token operator">=</span> math_vec_length_2<span class="token punctuation">,</span>
  test_func <span class="token operator">=</span> _test_func<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">return</span> list</code></pre>
<h3 id="lua的数据类型"><a href="#lua的数据类型" class="headerlink" title="lua的数据类型"></a>lua的数据类型</h3><p>table<br>function<br>nil<br>boolean<br>number：包括整数，浮点数等<br>string</p>
<p>userdata：userdata类型主要用来表示在C/C++中定义的类型，即用来实现扩展lua，这些扩展代码通常是用C/C++来实现的。对lua 虚拟机来说userdata只是提供了一块原始的内存区域，可以用来存储任何东西，并且在lua中userdata没有任何预定义的操作。注意这块分配的额外内存是由Lua垃圾收集器来管理的，无须关心起释放等情况。<br>thread：线程<br>注意：数据类型不是固定了，一个数据赋值了整型之后，也可以赋值字符串。<br>注意：函数也是变量的一种，可以随意赋值给变量<br>注意：字符串之间的拼接用..</p>
<pre class=" language-lua"><code class="language-lua"><span class="token keyword">local</span> a <span class="token operator">=</span> <span class="token number">5</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--打印类型</span>
foo2 <span class="token operator">=</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--函数的赋值</span>
      <span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
      <span class="token keyword">end</span>
<span class="token function">foo2</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre>
<h3 id="点和冒号的区别"><a href="#点和冒号的区别" class="headerlink" title="点和冒号的区别"></a>点和冒号的区别</h3><p>冒号隐式地传递了一个调用这个函数的表的示例进去，可以省略一个参数。</p>
<pre class=" language-lua"><code class="language-lua"><span class="token keyword">local</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">--下面两个函数等同</span>
<span class="token keyword">function</span> a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--这里self必须传进去本身才行</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"atest"</span><span class="token punctuation">,</span>self<span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token keyword">function</span> a<span class="token punctuation">:</span><span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"atest"</span><span class="token punctuation">,</span>self<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--冒号包含了self机制</span>
<span class="token keyword">end</span></code></pre>
<p>两者不能混着用，如果定义的是冒号，用的时候是点，就会导致找不到self而报错。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>语法域：函数可以嵌套在另一个函数中，内部函数可访问外部函数的局部变量，这样可以用来实现面向对象的编程<br>闭包：lua编译一个函数的时候，会生成一个原型prototype，包含了函数体对应的虚拟机指令，函数体中的常量，调试信息。运行的到函数的时候会创建一个新的数据对象，对象中包含了响应函数原型的引用和一个数组，包含了所有upvalue的引用（传进来的值），这个数据对象称为闭包。<br>注意：lua支持函数有多返回值</p>
<pre class=" language-lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
  <span class="token keyword">local</span> fuction <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
  <span class="token keyword">return</span> f2
<span class="token keyword">end</span>

g1 <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">)</span>
<span class="token function">g1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
g2 <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">)</span>
<span class="token function">g2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
  <span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token function">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
    <span class="token keyword">end</span>
    <span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      n <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">10</span>
    <span class="token keyword">end</span>
    <span class="token keyword">return</span> foo1<span class="token punctuation">,</span>foo2
  <span class="token keyword">end</span>
  <span class="token keyword">return</span> foo
<span class="token keyword">end</span>
f0 <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">)</span>
f1<span class="token punctuation">,</span>f2 <span class="token operator">=</span> <span class="token function">f0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
g1<span class="token punctuation">,</span>g2 <span class="token operator">=</span> <span class="token function">f0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">g1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">g2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">--闭包可以作为高阶函数的参数</span>
table<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span>t2<span class="token punctuation">)</span> <span class="token keyword">return</span> t1<span class="token punctuation">.</span>param <span class="token operator">></span> t2<span class="token punctuation">.</span>param <span class="token keyword">end</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">--重写（类似面向对象）,可以用来添加验证</span>
<span class="token keyword">local</span> oldOpen <span class="token operator">=</span> io<span class="token punctuation">.</span>open
<span class="token keyword">local</span> accessOk <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span>mode<span class="token punctuation">)</span>
                    <span class="token comment" spellcheck="true">--方法体</span>
                    <span class="token keyword">end</span>
io<span class="token punctuation">.</span>open <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span>mode<span class="token punctuation">)</span>
              <span class="token keyword">if</span> <span class="token function">accessOk</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span>mode<span class="token punctuation">)</span> <span class="token keyword">then</span>
                <span class="token keyword">return</span> <span class="token function">oldOpen</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span>mode<span class="token punctuation">)</span>
              <span class="token keyword">else</span>
                <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">,</span><span class="token string">"校验失败"</span>
              <span class="token keyword">end</span>
          <span class="token keyword">end</span>

<span class="token comment" spellcheck="true">--实现迭代器</span>
<span class="token keyword">function</span> <span class="token function">values</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
  <span class="token keyword">local</span> i <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">return</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">end</span>
  <span class="token keyword">end</span>
t <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span>
iter <span class="token operator">=</span> <span class="token function">values</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="C-和lua的相互调用"><a href="#C-和lua的相互调用" class="headerlink" title="C#和lua的相互调用"></a>C#和lua的相互调用</h3><p>c语言可以和lua直接通信，lua就是c语言开发的，C#要和lua通信，需要先调用C语言，C语言再调用lua，Xlua插件封装了C#调用C语言的接口。<br>C 调用 Lua 实际上是：由 C 先把数据放入栈中，由 Lua 去栈中取数据，然后返回数据对应的值到栈顶，再由栈顶返回 C。<br>Lua 调 C 也一样：先编写自己的 C 模块，然后注册函数到 Lua 解释器中，然后由Lua 去调用这个模块的函数。<br>Lua虚拟栈：从底往上是1到n，从顶往下时-1到-n，lua里面用到的数据类型都可以入栈</p>
<h3 id="Lua实现只读表"><a href="#Lua实现只读表" class="headerlink" title="Lua实现只读表"></a>Lua实现只读表</h3><pre class=" language-lua"><code class="language-lua"><span class="token keyword">local</span> readOnly
readOnly <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
  <span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token function">type</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"table"</span> <span class="token keyword">then</span>
      t<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">readOnly</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
  <span class="token keyword">local</span> nt <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">local</span> mt <span class="token operator">=</span> <span class="token punctuation">{</span>
    __index <span class="token operator">=</span> t<span class="token punctuation">,</span>
    __newindex <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
      <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"this is a readonly table"</span><span class="token punctuation">)</span>
      <span class="token keyword">end</span>
  <span class="token punctuation">}</span>
  <span class="token function">setmetatable</span><span class="token punctuation">(</span>nt<span class="token punctuation">,</span>mt<span class="token punctuation">)</span>
  <span class="token keyword">return</span> nt
<span class="token keyword">end</span>

<span class="token keyword">local</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
a <span class="token operator">=</span> <span class="token function">readOnly</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
a<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3</span> <span class="token comment" spellcheck="true">--错误</span></code></pre>
<p>当我们对readOnly的table进行赋值会调用newIndex函数，从而抛出错误</p>
<h3 id="Lua-GC"><a href="#Lua-GC" class="headerlink" title="Lua GC"></a>Lua GC</h3><p>从Lua 5.1开始，采用三色增量标记清除算法。好处：它不必再要求GC一次性扫描所有的对象，这个GC过程可以是增量的，可以被中断再恢复并继续进行的。3种颜色分类如下：</p>
<p>白色：当前对象为待访问状态，表示对象还没有被GC标记过，这也是任何一个对象创建后的初始状态。换言之，如果一个对象在结束GC扫描过程后仍然是白色，则说明该对象没有被系统中的任何一个对象所引用，可以回收其空间了。</p>
<p>灰色：当前对象为待扫描状态，表示对象已经被GC访问过，但是该对象引用的其他对象还没有被访问到。</p>
<p>黑色：当前对象为已扫描状态，表示对象已经被GC访问过，并且该对象引用的其他对象也被访问过了。当GC完后被重置为白色。<br>伪代码：</p>
<pre><code>每个新创建的对象颜色为白色

//初始化阶段
遍历root节点中引用的对象，从白色置为灰色，并且放入到灰色节点列表中

//标记阶段
当灰色链表中还有未扫描的元素：
    从中取出一个对象并将其标记为黑色
    遍历这个对象关联的其他所有对象：
        如果是白色：
        标记为灰色，加入灰色链表中

//回收阶段
遍历所有对象：
    如果为白色：
        这些对象都是没有被引用的对象，逐个回收
    否则：
        重新加入对象链表中等待下一轮的GC检查</code></pre>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="静态和单例模式"><a href="#静态和单例模式" class="headerlink" title="静态和单例模式"></a>静态和单例模式</h3><p>单例模式的本质就是类成员中有一个对象实例</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">string</span> Title <span class="token operator">=</span> <span class="token string">"Animal"</span> <span class="token comment" spellcheck="true">// 类成员</span>
  <span class="token keyword">public</span> <span class="token keyword">string</span> Name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对象成员</span>
  <span class="token keyword">public</span> <span class="token keyword">const</span> <span class="token keyword">float</span> Pi <span class="token operator">=</span> <span class="token number">3.14f</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类成员</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> <span class="token keyword">float</span> Pi2 <span class="token operator">=</span> <span class="token number">3.14f</span> <span class="token comment" spellcheck="true">// 对象成员</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> Animal animal<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//类成员</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> Animal Instance<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//实例</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> Animal Instance<span class="token punctuation">{</span>
    <span class="token keyword">get</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 类构造函数</span>
  <span class="token keyword">static</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 对象构造函数</span>
  <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>注意：</p>
<ol>
<li>我们也可以把整个类static来当做单例</li>
<li>使用单例时，我们把构造函数私有可以防止被人new，在类前加上seal防止被继承</li>
</ol>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>多人开发的时候，每个人开发不同的功能，每个人代码风格不一样，但是要用到别人提供的功能，别人还没有写对应的功能，这时候我们要用到事件，关心的人订阅这个事件即可，完全不用关心其他人的代码。我们可以用到C#里面的Action函数。<br>这样的订阅功能我们可以用一个EventManager来管理，包含至少以下方法：订阅事件，取消订阅事件，触发事件， 移除事件，我们可以通过一个字典来进行管理，键是对应的命名（可以用枚举），值就是对应的Action(可以封装一下)。</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>把一个功能的细节全部封装起来，只对外暴露使用者关心的部分。例如一场战斗开始之前我们需要初始化各个系统，有网络系统，团队系统，背包系统，AI系统等等，但是我们都把它封装到一个函数当中调用即可，对外只暴露一个初始化战斗的函数，战斗时候的更新同理，我们也可以把各个系统的更新集成到一起。<br>定义：为子系统定义一组统一的接口，这个高级接口让子系统更容易被使用。</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>枚举是关键。怪物的状态机是一个例子。不同的状态有不同的初始化动作，不同的更新动作，更新的时候有状态转移条件。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>概念：工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种将对象的创建和使用分离的方式。工厂模式通过定义一个创建对象的接口，但将具体的对象创建过程延迟到子类来完成。这样，客户端代码就不需要知道具体的对象创建细节，只需要通过工厂方法获取所需的对象。工厂模式的主要目的是封装对象的创建过程，使客户端与具体的对象类解耦，从而提供更大的灵活性和可维护性。<br>例子：MMORPG中输入网络端的信息即可调用对应的接口创建对应的角色。<br>工厂模式通常涉及以下角色：</p>
<p>抽象工厂（Abstract Factory）：定义了创建对象的接口，它是工厂方法模式的核心，具体工厂类实现了这个接口。</p>
<p>具体工厂（Concrete Factory）：实现抽象工厂接口，负责创建具体的产品对象。</p>
<p>抽象产品（Abstract Product）：定义了产品的接口，描述了产品的特性和功能。</p>
<p>具体产品（Concrete Product）：实现抽象产品接口，是被创建的对象。</p>
<p>工厂模式的工作流程如下：</p>
<p>客户端通过调用抽象工厂的方法创建产品对象，而不直接实例化具体产品类。</p>
<p>抽象工厂根据客户端的请求，选择合适的具体工厂来创建产品对象。</p>
<p>具体工厂根据客户端的请求，创建具体的产品对象，并将其返回给客户端。</p>
<p>工厂模式的好处在于当新增一个类的时候我们不会对原来的代码进行修改，只新增类本身及其工厂。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>根据不同的条件需求，构建不同的实例，并且在策略模式内 封装具体的自定义行为接口<br>应用场景<br>例如: 游戏设置界面，根据GPU品质，批量设置群组显示效果</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令是对命令的封装，每一个命令都是一个操作，请求方发出请求，接收方接收请求，并执行操作。命令模式解耦了请求方和接收方，命令模式属于行为型模式<br>有执行队列的需求，且支持撤销需求<br>应用场景<br>例如: 比如FPS 输入模块，需要存储某些输入指令时<br>优点：<br>通过引入命令的抽象接口，实现了命令请求与实现的解耦<br>扩展性良好，可以很容易的增加新命令</p>
<h3 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h3><ol>
<li>单一职责原则：一个类只做一件事情</li>
<li>开放-封闭原则：对于扩展是开放的，对于更改是封闭的</li>
<li>Liskov替换原则：子类必须能替换基类</li>
<li>依赖倒置原则：依赖于抽象，在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。</li>
<li>接口隔离原则：使用小的专门接口，不要使用大的总接口</li>
</ol>
<h3 id="行为树和状态机的区别"><a href="#行为树和状态机的区别" class="headerlink" title="行为树和状态机的区别"></a>行为树和状态机的区别</h3><p>有限状态机系统：是指在不同阶段会呈现出不同的运行状态的系统，这些状态是有限的、不重叠的。这样的系统在某一时刻一定会处于其所有状态中的一个状态，此时它接收一部分允许的输入，产生一部分可能的响应，并且迁移到一部分可能的状态。</p>
<ol>
<li>基本节点是状态：他包含了一系列运行在该状态的行为以及离开这个状态的条件。</li>
<li>状态可以任意跳转,实现简单,但是对于大的状态机很难维护.状态逻辑的重用性低.</li>
<li>每一个状态的逻辑会随着一些新状态的增加而越来越复杂。维持状态的数量和状态逻辑复杂性是一个很大的难点。需要合理的分割以及重用状态。</li>
<li>状态机状态的复用性很差，一旦一些因素变化导致这个环境发生变化。你只能新增一个状态，并且给这个新状态添加连接他以及其他状态的跳转逻辑。</li>
<li>状态机的跳转条件一旦不满足，就会一直卡在某一个状态。</li>
</ol>
<p>行为树：一个流行的 AI 技术，涵盖了层次状态机，事件调度，事件计划，行为等一<br>系列技术。</p>
<ol>
<li>高度模块化状态，去掉状态中的跳转逻辑，使得状态变成一个“行为”。</li>
<li>“行为”和”行为”之间的跳转是通过父节点的类型来决定的。比如并行处理两个行为，在状态机里面无法同时处理两个状态。</li>
<li>通过增加控制节点的类型，可以达到复用行为的目的。</li>
<li>行为树具有树状结构，节点之间的连接关系可以灵活组合和修改。在Unity中，可以使用行为树编辑器进行可视化编辑和调整，可以快速修改和调试行为树的逻辑。这使得开发人员可以快速迭代和调整角色的行为逻辑，提高开发效率。</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>这一部分参考以前的文章《Unity游戏开发基础知识》</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表代表了键值对集合，使用键访问集合中的元素。用法比较简单。</p>
<pre class=" language-csharp"><code class="language-csharp">Hashtable ht1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hshtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ht1<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ht1<span class="token punctuation">.</span><span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>ht1<span class="token punctuation">.</span><span class="token function">ContainsKey</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"包含键为“1”的数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
ht1<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>ht1<span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//读取</span>
ht1<span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">99</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//修改</span>
ICollection key <span class="token operator">=</span> ht1<span class="token punctuation">.</span>Keys<span class="token punctuation">;</span>
<span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token keyword">in</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//遍历</span>
  Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>ht1<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>和字典的不同在于可以存储任何类型的变量，不需要提前定义，但需要拆箱装箱。<br>哈希表本质上是通过数组储存的，一般把Key输入哈希函数中，计算出哈希值，把用这个哈希值作为数组的索引来读取和修改Value。<br>如果不同的Key计算出了同一个哈希值，称为发生了哈希冲突（哈希碰撞），因此设计合适的哈希函数很重要（直接定址法，数字分析法，折叠法，随机数法和除留余数法等等）</p>
<h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4><p><strong>直接定址法</strong><br>取关键字或者关键字的某个线性函数为 Hash 地址，即address(key) = a * key + b; 如知道学生的学号从2000开始，最大为4000，则可以将address(key)=key-2000(其中a = 1)作为Hash地址。</p>
<p><strong>平方取中法</strong><br>对关键字进行平方计算，取结果的中间几位作为 Hash 地址。如有以下关键字序列 {421，423，436} ，平方之后的结果为 {177241，178929，190096} ，那么可以取中间的两位数 {72，89，00} 作为 Hash 地址。</p>
<p><strong>折叠法</strong><br>将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。如图书的 ISBN 号为 8903-241-23，可以将 address(key)=89+03+24+12+3 作为 Hash 地址。</p>
<p><strong>除留取余法</strong><br>如果知道 Hash 表的最大长度为 m，可以取不大于m的最大质数 p，然后对关键字进行取余运算，address(key)=key % p。这里 p 的选取非常关键，p 选择的好的话，能够最大程度地减少冲突，p 一般取不大于m的最大质数。</p>
<p><strong>随机数法</strong><br>  选择一个随机函数，取关键字的随机函数值作为它的哈希地址，即H(key)=random(key)，其中random为随机函数。通常用于关键字长度不等时的场合。</p>
<h4 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h4><p>解决哈希冲突的方法有<strong>开放寻址法</strong>（一个位置被占了就一直找下一个位置），<strong>拉链法</strong>：通过在数组的位置上额外存放一个指针指向另外的一个位置（相当于链表），然后去下一个位置看是否有冲突，有冲突就继续走向这个位置指针的下一个位置，以此类推。<br>当哈希表被占领的位置过多（例如超过70%），就会触发扩容机制，创建一个新的数组，长度为原来的两倍，并且重新利用哈希函数计算位置。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>C#中是有前驱和后驱的双向链表。链表在内存中是离散的，不连续。通过两个指针指向上一个存储位置和下一个存储位置。<br>链表在删除和插入的时候效率比列表和数组快，但查找的时候只能靠遍历，比较慢。</p>
<p>链表可以分为单向和双向。</p>
<pre class=" language-csharp"><code class="language-csharp">LinkedList<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> linList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
LinkedListNode<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> node<span class="token punctuation">;</span>  
node <span class="token operator">=</span> linList<span class="token punctuation">.</span><span class="token function">AddFirst</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//第一个节点</span>
linlist<span class="token punctuation">.</span><span class="token function">AddAfter</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//添加在某节点后面+具体值</span>
linlist<span class="token punctuation">.</span><span class="token function">AddBefore</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//添加在某节点前面+具体值</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>linList<span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>linList<span class="token punctuation">.</span>First<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//第一个值</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>linList<span class="token punctuation">.</span>Last<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最后一个值</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Previous<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//节点前一个值</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Next<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//节点后一个值</span>
</code></pre>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>链表逆序（反转链表）的方法：<br>方法一：就地逆序<br>方法二：递归法<br>方法三：插入法</p>
<p>就地逆序：</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
  pre <span class="token operator">=</span> None
  cur <span class="token operator">=</span> head
  <span class="token keyword">while</span> cur<span class="token punctuation">:</span>
    nxt <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre
    pre <span class="token operator">=</span> cur
    cur <span class="token operator">=</span> nxt
  <span class="token keyword">return</span> pre
</code></pre>
<p>插入法：<br>从链表的第二个结点开始，把遍历到的结点插入到头结点的后面，直到遍历结束。假如原链表为head-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7，在遍历到2的时候，将2插入到头结点的后面，链表变为head-&gt;2-&gt;1-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7，同理head-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;6-&gt;7等等。</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insertReverse</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 特殊情况：头节点为空，或者只有单个节点</span>
    <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token comment" spellcheck="true"># 操作头节点, 2次指针操作,头节点head.next赋值给cur, 由于头节点最终要成为尾结点,其指向为空</span>
    cur <span class="token operator">=</span> head<span class="token punctuation">.</span>next
    head<span class="token punctuation">.</span>next <span class="token operator">=</span> None
    <span class="token comment" spellcheck="true"># 操作第二个及之后的节点,每次遍历到的节点都放到头节点处</span>
    <span class="token keyword">while</span> cur<span class="token punctuation">:</span>
        nex <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head
        head <span class="token operator">=</span> cur
        cur <span class="token operator">=</span> nex
    <span class="token keyword">return</span> head
</code></pre>
<h4 id="判断链表有环"><a href="#判断链表有环" class="headerlink" title="判断链表有环"></a>判断链表有环</h4><p>首先从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点，用新节点ID和此节点之前所有节点ID(即重新遍历len-1步)依次作比较。如果发现新节点之前的所有节点当中存在相同节点ID，则说明该节点被遍历过两次，链表有环；如果之前的所有节点当中不存在相同的节点，就继续遍历下一个新节点，继续重复刚才的操作。<br>例如这样的链表：A-&gt;B-&gt;C-&gt;D-&gt;B-&gt;C-&gt;D， 当遍历到节点D的时候，我们需要比较的是之前的节点A、B、C，不存在相同节点。这时候要遍历的下一个新节点是B，B之前的节点A、B、C、D中恰好也存在B，因此B出现了两次，判断出链表有环。<br>方法一、穷举遍历</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> ListNode <span class="token punctuation">{</span>
     <span class="token keyword">int</span> val<span class="token punctuation">;</span>
     ListNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
     <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

bool <span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>tem <span class="token operator">=</span> head<span class="token punctuation">,</span><span class="token operator">*</span>temp<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>tem<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token operator">*</span>temp <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">==</span>tem<span class="token punctuation">)</span> <span class="token keyword">return</span> true<span class="token punctuation">;</span>
            temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        len<span class="token operator">++</span><span class="token punctuation">;</span>
        tem <span class="token operator">=</span> tem<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution1</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    思路分析:
    判断一个单链表是否有环,
    可以用 set 存放每一个 节点, 这样每次 访问后把节点丢到这个集合里面.
    其实 可以遍历这个单链表, 访问过后,
    如果这个节点 不在 set  里面, 把这个节点放入到 set 集合里面.
    如果这个节点在  set 里面 , 说明曾经访问过, 所以这个链表有重新 走到了这个节点, 因此一定有环.

    如果链表都走完了, 把所有的节点都放完了. 还是没有重复的节点, 那说明没有环.

    """</span>

    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>

        mapping <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>

        flag <span class="token operator">=</span> <span class="token boolean">False</span>

        p <span class="token operator">=</span> head

        <span class="token keyword">while</span> p<span class="token punctuation">:</span>

            <span class="token keyword">if</span> p <span class="token operator">not</span> <span class="token keyword">in</span> mapping<span class="token punctuation">:</span>
                mapping<span class="token punctuation">.</span>add<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                flag <span class="token operator">=</span> <span class="token boolean">True</span>
                <span class="token keyword">break</span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next

        <span class="token keyword">return</span> flag</code></pre>
<p>方法二、哈希表/set 缓存<br>哈希表：首先创建一个以节点ID为键的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就用新节点和HashSet集合当中存储的节点作比较，如果发现HashSet当中存在相同节点ID，则说明链表有环，如果HashSet当中不存在相同的节点ID，就把这个新节点ID存入HashSet，之后进入下一节点，继续重复刚才的操作。</p>
<p>set集合：还可以用 set 遍历链表，把节点放入set里，每次访问下个节点时，如果set长度不变，则跳出，说明有环。否则set长度+1，继续遍历。</p>
<pre class=" language-csharp"><code class="language-csharp">ListNode <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">set</span><span class="token operator">&lt;</span>ListNode<span class="token operator">*</span> node<span class="token operator">></span> s<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
              head <span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵别称为左子树和右子树的二叉树组成。<br>二叉树的特点：</p>
<ul>
<li>每个结点最多有两棵子树，即二叉树不存在度大于2的结点。</li>
<li>二叉树的子树有左右之分，其子树的次序不能颠倒。</li>
<li>满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</li>
<li>完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。</li>
<li>二叉树的顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4></li>
</ul>
<ol>
<li><p>若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有2^(i-1) 个结点.</p>
</li>
<li><p>若规定根节点的层数为1，则深度为h的二叉树的最大结点数是2^h- 1.</p>
</li>
<li><p>对任何一棵二叉树, 如果度为0其叶结点个数为 n0, 度为2的分支结点个数为 n2,则有n0＝n2＋1</p>
</li>
<li><p>若规定根节点的层数为1，具有n个结点的满二叉树的深度，h=Log2(n+1). (ps：Log2(n+1)是log以2为<br>底，n+1为对数)</p>
</li>
<li><p>对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对于序号为i的结点有：</p>
<ul>
<li>若i&gt;0，i位置节点的双亲序号：(i-1)/2；i=0，i为根节点编号，无双亲节点</li>
<li>若2i+1&lt;n，左孩子序号为2i+1，2i+1&gt;=n否则无左孩子</li>
<li>若2i+2&lt;n，右孩子序号为2i+2，2i+2&gt;=n否则无右孩子</li>
</ul>
</li>
</ol>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程学到高阶数据结构如红黑树等会用到三叉链。</p>
<pre class=" language-c"><code class="language-c"> <span class="token comment" spellcheck="true">// 二叉链</span>
   <span class="token keyword">struct</span> BinaryTreeNode
   <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> BinTreeNode<span class="token operator">*</span> _pLeft<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向当前节点左孩子</span>
    <span class="token keyword">struct</span> BinTreeNode<span class="token operator">*</span> _pRight<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向当前节点右孩子</span>
    BTDataType _data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前节点值域</span>
   <span class="token punctuation">}</span>
   <span class="token comment" spellcheck="true">// 三叉链</span>
   <span class="token keyword">struct</span> BinaryTreeNode
   <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> BinTreeNode<span class="token operator">*</span> _pParent<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向当前节点的双亲</span>
    <span class="token keyword">struct</span> BinTreeNode<span class="token operator">*</span> _pLeft<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向当前节点左孩子</span>
    <span class="token keyword">struct</span> BinTreeNode<span class="token operator">*</span> _pRight<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向当前节点右孩子</span>
    BTDataType _data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前节点值域</span>
   <span class="token punctuation">}</span>；</code></pre>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chinesekobe/article/details/110874773">https://blog.csdn.net/chinesekobe/article/details/110874773</a><br>所谓遍历(Traversal)是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。访问结点所做的操作依赖于具体的应用问 题。 遍历是二叉树上最重要的运算之一，是二叉树上进行其它运算之基础。<br>NLR：前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前。相当于从顶部开始，逆时针绕圈。<br>LNR：中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中（间）。相当于从左往右排序，每个父节点都在其左右子节点的中间。<br>LRN：后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。相当于从左往右，一次从叶子节点取一个元素下来，依次取到顶部。</p>
<p>深度优先遍历：似于先序遍历。<br>广度优先遍历：按每一层从上到下，从左到右进行遍历。</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//    先序遍历</span>
<span class="token keyword">void</span> <span class="token function">ShowXianXu</span><span class="token punctuation">(</span>BitTree T<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//        先序遍历二叉树</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">//    递归中遇到NULL，返回上一层节点</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ShowXianXu</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//    递归遍历左子树</span>
    <span class="token function">ShowXianXu</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//    递归遍历右子树</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//    中序遍历</span>
<span class="token keyword">void</span> <span class="token function">ShowZhongXu</span><span class="token punctuation">(</span>BitTree T<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//        先序遍历二叉树</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">//    递归中遇到NULL，返回上一层节点</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">ShowZhongXu</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//    递归遍历左子树</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ShowZhongXu</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//    递归遍历右子树</span>

<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//    后序遍历</span>
<span class="token keyword">void</span> <span class="token function">ShowHouXu</span><span class="token punctuation">(</span>BitTree T<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//        后序遍历二叉树</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">//    递归中遇到NULL，返回上一层节点</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">ShowHouXu</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//    递归遍历左子树</span>
    <span class="token function">ShowHouXu</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//    递归遍历右子树</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>前序非递归遍历：<br>这里使用栈来实现，首先将根放进栈中然后定义一个循环，循环条件是栈不为空，首先将栈顶元素弹出，并用一个结点保存，如果栈顶的元素不是空，就输出栈顶元素的数据，然后看它的左右子树，先把右子树压入栈中，再压左子树，（因为栈后进先出，先要访问左子树，所以左子树后进入），每次进入循环如果栈顶为空的化就不进行操作，直接进行操作，如果栈顶不为空的话再进行下面操作。直到所有结点都被遍历。<br>中序非递归遍历：<br>还是利用栈，因为先访问最左边的结点，所有我们先定义一个循环一直向左走把左边的所有结点压入栈中，这时候栈顶就是最左侧得结点，我们要将这个接单弹出，然后输出它的值，下来输出的是它的根结点，所以先要把它的右子树都压入栈中，最后再保存根结点就能保证先输出根结点再输出它右侧元素了。<br>后序非递归遍历：<br>还是利用栈，和中序非递归类似，先找到最左边的结点，并把这条路径上所有的结点按照找的顺序压入栈中，然后将最左侧结点的数据打印出来，然后判断当前节点是不是栈顶结点的左子树，如果是要先访问右结点才能访问根结点，否则将当前结点置成空，下一次就会输出当前结点的根结点，然后重复上述操作。</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#前序</span>
<span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span> 
  res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> 
  <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>  
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> 
  stack<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span> 
  <span class="token keyword">while</span> stack<span class="token punctuation">:</span> 
    node<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> 
    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> 
    <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> 
    <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">,</span>left<span class="token punctuation">)</span> 
  <span class="token keyword">return</span> res
<span class="token comment" spellcheck="true">#中序</span>
<span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span> 
  stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> 
  node<span class="token operator">=</span>root 
  res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> 
  <span class="token keyword">while</span> stack <span class="token operator">or</span> node<span class="token punctuation">:</span> 
    <span class="token keyword">while</span> node<span class="token punctuation">:</span> 
      stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span> 
      node<span class="token operator">=</span>node<span class="token punctuation">.</span>left 
    node<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> 
    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> 
    node<span class="token operator">=</span>node<span class="token punctuation">.</span>right 
  <span class="token keyword">return</span> res
<span class="token comment" spellcheck="true"># 后序</span>
<span class="token keyword">def</span> <span class="token function">laorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span> 
  stack<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span> 
  res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> 
  <span class="token keyword">while</span> stack<span class="token punctuation">:</span> 
    node<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> 
    <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> 
    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> 
  <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre>
<pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiNode <span class="token operator">*</span>bt<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//树的前序遍历</span>
    SqStack s<span class="token punctuation">;</span>
    s <span class="token operator">=</span> <span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiNode <span class="token operator">*</span>p <span class="token operator">=</span> bt<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> <span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//当p为空，栈也为空时退出循环</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问根结点</span>
            <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将指针p的节点压入栈中</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>Lchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//遍历左子树</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//栈不为空</span>
            p <span class="token operator">=</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//根结点出栈,相当于回退</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//遍历右子树</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">DestroyStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">MidOrder</span><span class="token punctuation">(</span>BiNode <span class="token operator">*</span>bt<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//树的中序遍历</span>
    SqStack s<span class="token punctuation">;</span>
    s <span class="token operator">=</span> <span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiNode <span class="token operator">*</span>p <span class="token operator">=</span> bt<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> <span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//当p为空，栈也为空时退出循环</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将指针p的节点压入栈中</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>Lchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//遍历左子树</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//栈不为空</span>
            p <span class="token operator">=</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//根结点出栈,相当于回退</span>
            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问根结点</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//遍历右子树</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">DestroyStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiNode <span class="token operator">*</span>bt<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//树的后序遍历</span>
    SqStack s<span class="token punctuation">;</span>
    s <span class="token operator">=</span> <span class="token function">InitStack_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiNode <span class="token operator">*</span>p <span class="token operator">=</span> bt<span class="token punctuation">;</span>
    element elem<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> <span class="token function">StackEmpty_1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//当p为空，栈也为空时退出循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//第一次入栈，访问左子树</span>
            elem<span class="token punctuation">.</span>ptr <span class="token operator">=</span> p<span class="token punctuation">;</span>
            elem<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//标记flag为1，表示即将第一次入栈</span>
            <span class="token function">Push_1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将指针p的结点第一次压入栈中</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>Lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            elem <span class="token operator">=</span> <span class="token function">Pop_1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//出栈</span>
            p <span class="token operator">=</span> elem<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//p指向当前要处理的结点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elem<span class="token punctuation">.</span>flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//flag==1时，说明只访问过左子树，还要访问右子树</span>
                elem<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token function">Push_1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//结点第二次压入栈中</span>
                p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//flag==2时，左右子树都已经访问过了</span>
                <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
                p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问后，p赋为空，确保下次循环时继续出栈（相当于回退）</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">DestroyStack_1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h4><p>将每个节点的左右节点互换，也就是遍历每一个节点然后交换它们的左右节点，这里就可用到二叉树的各种遍历方法，只是将保存节点值的过程转换为交换左右节点。（中序遍历不能使用，会将某些节点反转两次）</p>
<pre class=" language-c++"><code class="language-c++">//前序遍历解决问题
public TreeNode invertTree(TreeNode root) {
    if(root==null) return null;
    //反转左右孩子
    TreeNode temp=root.left;
    root.left=root.right;
    root.right=temp;
    invertTree(root.left); //左
    invertTree(root.right); //右
    return root;
}</code></pre>
<h4 id="排序二叉树找第k大节点"><a href="#排序二叉树找第k大节点" class="headerlink" title="排序二叉树找第k大节点"></a>排序二叉树找第k大节点</h4><p>题目：</p>
<pre><code>输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4

示例 2:
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4

限制：
1 ≤ k ≤ 二叉搜索树元素个数</code></pre>
<p>答案：</p>
<pre class=" language-c++"><code class="language-c++">class Solution {
public:
    int kthLargest(TreeNode* root, int k) {
        //右根左降序遍历
        stack<TreeNode*> s;
        while(root || !s.empty())
        {
            while(root)
            {
                s.push(root);
                root = root->right;
            }
            root = s.top();
            s.pop();
            k--;
            if(k==0)
                return root->val;
            root = root->left;
        }
        return -1;
    }
};</code></pre>
<p>在这段代码中，使用右根左的遍历顺序是为了实现降序遍历二叉搜索树（Binary Search Tree）。降序遍历意味着按照节点值的降序来访问节点。<br>对于二叉搜索树而言，中序遍历可以实现升序遍历，即从小到大访问节点。而右根左的遍历顺序是中序遍历的逆序，所以可以实现从大到小访问节点，即降序遍历。<br>在这个特定的问题中，要找到二叉搜索树中第 k 大的元素。通过降序遍历，我们可以依次访问每个节点的值，并在第 k 个节点时返回对应的值，即为第 k 大的元素。<br>使用栈来辅助遍历的过程，可以实现迭代方式的降序遍历。从根节点开始，先将右子树的节点依次入栈，然后弹出栈顶元素，进行相应的处理（比如减小 k 的值，判断是否为第 k 大的元素），然后将左子节点作为下一个要处理的节点。<br>因此，使用右根左的遍历顺序是为了满足降序遍历的需求，并能够有效地找到第 k 大的元素。</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>二叉树能提高查询的效率 O(logn)，但是当你插入{1,2,3,4,5,6} 这种数据的时候，你的二叉树就像一个链表一样，搜索效率变为 O(n)</p>
<p>所以一般的二叉搜索树在进行数据的存储时可能会使工作的时间复杂度并未降低太多，这时便需要我们将二叉树的高度尽可能的降低，使二叉树的高度降低为log(n)，这样我们就得到了一个高度平衡的二叉搜索树，使对于数据的一系列操作的时间复杂度稳定在 O(logn)。<br>红黑树就是一颗自平衡的二叉树。</p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>跳表（Skip List）是一种用于实现有序集合的数据结构，它通过在一个<strong>有序链表的基础上添加多层索引</strong>来提高数据的查找效率。跳表允许快速地按照元素的键值进行查找、插入和删除操作。<br>跳表的核心思想是通过建立多级索引层次，使得较大范围的元素可以通过跳过一些节点来进行快速搜索。每一级索引都是原始链表的一个子集，且比前一级索引稀疏，即包含更少的节点。最底层的索引就是原始的有序链表。<br>在跳表中，每个节点包含一个键值对，键用于按照有序方式进行排序，值则是具体存储的数据。每个节点还包含指向下一级索引节点的指针，使得可以在不同层次的索引之间进行快速的跳跃。</p>
<p>查找：从顶层往下，如果下一个指向的节点索引大于我们需要查找的索引，那么就跳到下一层。<br>插入：当我们在跳表中插入数据的时候，我们通过选择同时将这个数据插入到部分索引层中，如何选择索引层，可以通过一个随机函数来决定这个节点插入到哪几级索引中，比如随机生成了k，那么就将这个索引加入到，第一级到第k级索引中。<br>删除：和链表插入删除一致，不过是多了几层</p>
<pre class=" language-c++"><code class="language-c++">public Node find(E e) {
    if (empty()) {
        return null;
    }
    return find(e, head, curLevel);
}

private Node find(E e, Node current, int level) {
    while (level >= 0) {
        current = findNext(e, current, level);
        level--;
    }
    return current;
}

//返回给定层数中小于e的最大者
private Node findNext(E e, Node current, int level) {
    Node next = current.next(level);
    while (next != null) {
        if (e.compareTo(next.data) < 0) {
            break;
        }
        //到这说明e >= next.data
        current = next;
        next = current.next(level);
    }
    return current;
}</code></pre>
<p>跳表的查询效率是时间复杂度是 nlogn</p>
<h3 id="红黑树（难）"><a href="#红黑树（难）" class="headerlink" title="红黑树（难）"></a>红黑树（难）</h3><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaofeng10330111/article/details/106080394">https://blog.csdn.net/xiaofeng10330111/article/details/106080394</a><br>红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，它在<strong>插入和删除操作后能够自动调整树的结构</strong>，保持树的平衡性。红黑树是在普通二叉搜索树的基础上增加了一些附加的规则和性质来确保平衡。</p>
<p>红黑树的特点包括：</p>
<ol>
<li>根节点是黑色的。</li>
<li>每个叶子节点（NIL 节点，空节点）是黑色的。</li>
<li>如果一个节点是红色的，那么它的两个子节点都是黑色的。</li>
<li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数量的黑色节点。</li>
</ol>
<p>这些特性保证了红黑树的关键性质，包括：<br>任意节点到其每个叶子节点的路径长度相等或差至多为1，因此树的高度是对数级别的，保持了较好的平衡性。<br>查找、插入和删除操作的时间复杂度为 O(log n)，保持了较高的操作效率。</p>
<p>旋转操作<br>在分析插入和删除操作前，先说明一下旋转操作，这个操作在后续操作中都会用得到。旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子。</p>
<ol>
<li>如果插入节点位置是根部，节点为黑色，其他位置是红色</li>
</ol>
<p>总共就会有12种情况，其中四种情况满足红黑树的性质，8种情况不满足红黑树性质。<br>parent 为黑色节点。四种情况不需要做任何额外的处理。<br>parent 为红色节点（ Double Red ），其中左面4种属于B树节点上溢的情况（一个4阶B树节点中最多存放三个数，这四种情况本来已经有3个了，又插入了1个，变成了4个，超出了4阶B树节点的容量范围，这种情况称为上溢）。这八种情况需要进行额外的处理。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(1)$</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>$O(n)$</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span></code></pre>
<p>$O(n^2)$</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span></code></pre>
<p>$O(nm)$</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span></code></pre>
<p>$O(\log n)$</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
        i <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span></code></pre>
<p>$O(n \log n)$</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
            i <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    a<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    b<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>$O(n)$</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>$O(n^2)$</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">,</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="稳定性和冒泡排序"><a href="#稳定性和冒泡排序" class="headerlink" title="稳定性和冒泡排序"></a>稳定性和冒泡排序</h3><p>稳定性：当需要排序的序列中存在相同关键字的元素，排序后的相对次序保持不变，则算法稳定，稳定的排序算法会保留数值项顺序的表达意义。<br>冒泡排序：</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>时间复杂度为$O(n^2)$，空间复杂度$O(1)$</p>
<p>改进版：</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>   
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            flag <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                flag <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre class=" language-c"><code class="language-c">
<span class="token keyword">void</span> <span class="token function">arr_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
    <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//排序次数</span>
    <span class="token punctuation">{</span>
        min <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> p<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                min <span class="token operator">=</span> j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录交换的元素下标值</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> min<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>
            p<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
    ls <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">var</span> r <span class="token keyword">in</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
        ls <span class="token operator">+</span><span class="token operator">=</span> r <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"轮次"</span> <span class="token operator">+</span> index<span class="token operator">++</span> <span class="token operator">+</span> <span class="token string">"数组"</span> <span class="token operator">+</span> ls<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>时间复杂度为$O(n^2)$，空间复杂度$O(1)$</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是对插入排序的优化。</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
    ls <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">var</span> r <span class="token keyword">in</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
        ls <span class="token operator">+</span><span class="token operator">=</span> r <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"轮次"</span> <span class="token operator">+</span> index<span class="token operator">++</span> <span class="token operator">+</span> <span class="token string">"数组"</span> <span class="token operator">+</span> ls<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> step <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> step <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> step <span class="token operator">=</span> step <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> step<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> step <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> step<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> step<span class="token punctuation">)</span><span class="token punctuation">{</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> step<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>           
            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>时间复杂度$O(n^2)$，空间复杂度$O(1)$，稳定性是不稳定的</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆是一颗完全的二叉树，堆中某个节点的值总是不大于（大顶堆）或不小于（小顶堆）其父节点的值</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 构建初始堆</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span>Length <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">AdjustHeap</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span>i<span class="token punctuation">,</span>list<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// O(n)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 进行n-1次循环，完成排序</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// O(nlogn)</span>
        <span class="token comment" spellcheck="true">// 交换堆顶（最大数）到最后，并把这个节点从二叉树去掉</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 只有堆顶不确定是不是最大，只调整堆顶即可</span>
        <span class="token function">AdjustHeap</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">AdjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> parent <span class="token punctuation">,</span><span class="token keyword">int</span> Length<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 父节点</span>
    <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> parent <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 左子节点</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>child <span class="token operator">&lt;</span> Length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 找最大的子节点</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> Length <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            child<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">>=</span> array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果子节点较大，交换父子节点</span>
        array<span class="token punctuation">[</span>parent<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 子节点作为父节点，进行下一轮比较</span>
        parent <span class="token operator">=</span> child<span class="token punctuation">;</span>
        child <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    array<span class="token punctuation">[</span>parent<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>时间复杂度$O(n\log n)$，空间复杂度$O(1)$，稳定性是不稳定的</p>
<h3 id="二叉树排序"><a href="#二叉树排序" class="headerlink" title="二叉树排序"></a>二叉树排序</h3><p>二叉排序树：空树或满足以下条件</p>
<ol>
<li>如果左子树不空，左子树上的所有节点值均小于根节点的值。如果右子树不空，右子树上的所有节点均大于根节点的值。</li>
<li>左、右子树分别为二叉排序树。<br>遍历顺序：<br>中序遍历（左根右）、先序遍历（根左右）、后序遍历（左右根）<br>我们采用中序遍历，也就是说，二叉排序树从小到大的遍历顺序是从最后最左的子节点开始，往上遍历，遍历到父节点的时候，再从下往上，从左往右遍历右子节点，如此往复，遍历完左右节点。<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinarySortTreeNode</span><span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">int</span> Key<span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
 <span class="token keyword">public</span>  BinarySortTreeNode Left<span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
 <span class="token keyword">public</span> BinarySortTreeNode Right<span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
 <span class="token keyword">public</span> <span class="token function">BinarySortTreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>
     Key <span class="token operator">=</span> key<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">var</span> tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinarySortTreeNode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>Key <span class="token operator">&lt;=</span> Key<span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token keyword">if</span><span class="token punctuation">(</span>Left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             Left <span class="token operator">=</span> tree<span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">else</span><span class="token punctuation">{</span>
             Left<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">else</span><span class="token punctuation">{</span>
             <span class="token keyword">if</span><span class="token punctuation">(</span>Right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                 Right <span class="token operator">=</span> tree<span class="token punctuation">;</span>
             <span class="token punctuation">}</span>
             <span class="token keyword">else</span><span class="token punctuation">{</span>
                 Right<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token punctuation">}</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token comment" spellcheck="true">// 遍历方法（妙啊）</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">InorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     Left<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">InorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>Key<span class="token punctuation">)</span><span class="token punctuation">;</span>
     Right<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">InorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
</ol>
<p>public static void BinaryTreeSort(int[] array){<br>    var binarySortTreeNode = new BinarySortTreeNode(array[0]);<br>    for(int i = 1; i &lt; array.Length; i++){<br>        binarySortTreeNode.Insert(array[i]);<br>    }<br>    binarySortTreeNode.InorderTraversal();<br>}</p>
<pre><code>时间复杂度$O(n\log n)$，空间复杂度$O(n)$，稳定性是不稳定的

### 快速排序
参考：https://blog.csdn.net/qq_40941722/article/details/94396010
```c
void Quick_Sort(int *arr, int begin, int end){
    if(begin &gt; end)
        return;
    int tmp = arr[begin];
    int i = begin;
    int j = end;
    while(i != j){
        while(arr[j] &gt;= tmp &amp;&amp; j &gt; i)
            j--;
        while(arr[i] &lt;= tmp &amp;&amp; j &gt; i)
            i++;
        if(j &gt; i){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[begin] = arr[i];
    arr[i] = tmp;
    Quick_Sort(arr, begin, i-1);
    Quick_Sort(arr, i+1, end);
}
</code></pre>
<pre class=" language-lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">Sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> leftIndex<span class="token punctuation">,</span> rightIndex<span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>leftInfex <span class="token operator">>=</span> rightIndex<span class="token punctuation">)</span> <span class="token keyword">then</span>
    <span class="token keyword">return</span>
  <span class="token keyword">end</span>
  <span class="token keyword">local</span> i <span class="token operator">=</span> leftIndex
  <span class="token keyword">local</span> j <span class="token operator">=</span> rightIndex
  <span class="token keyword">local</span> baseValue <span class="token operator">=</span> list<span class="token punctuation">[</span>leftIndex<span class="token punctuation">]</span>

  <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j <span class="token keyword">do</span>
    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j <span class="token keyword">and</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> baseValue <span class="token keyword">do</span>
      j <span class="token operator">=</span> j <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">end</span>
    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j <span class="token keyword">and</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> baseValue <span class="token keyword">do</span>
      i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">end</span>
    <span class="token keyword">if</span> j <span class="token operator">></span> i <span class="token keyword">then</span>
      t <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
      list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
  list<span class="token punctuation">[</span>leftIndex<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> baseValue<span class="token punctuation">;</span>
  <span class="token function">Quick_Sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> leftIndex<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">Quick_Sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> rightIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">end</span>
</code></pre>
<p>快速排序最优时间复杂度为O(nlogn)，不稳定</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Pt4y197VZ/">https://www.bilibili.com/video/BV1Pt4y197VZ/</a></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> startIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> endIndex <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 递归结束条件：startIndex大于等于endIndex的时候</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">>=</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 折半递归</span>
    <span class="token keyword">let</span> midIndex <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>startIndex <span class="token operator">+</span> endIndex<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> midIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> midIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 将两个有序的小数组，合并成一个大数组</span>
    <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> midIndex<span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> midIndex<span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 新建一个大数组</span>
    <span class="token keyword">let</span> tempArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> p1 <span class="token operator">=</span> startIndex<span class="token punctuation">;</span>
    <span class="token keyword">let</span> p2 <span class="token operator">=</span> midIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 比较两个有序小数组的元素，依次放入大数组中</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> midIndex <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            tempArr<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            tempArr<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 右侧小数组已排序完毕，左侧小数组还有剩余，将左侧小数组元素依次放入大数组尾部</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> midIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tempArr<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 左侧小数组已排序完毕，右侧小数组还有剩余，将右侧小数组元素依次放入大数组尾部</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tempArr<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tempArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arr<span class="token punctuation">[</span>i <span class="token operator">+</span> startIndex<span class="token punctuation">]</span> <span class="token operator">=</span> tempArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>时间复杂度是O(nlogn)，稳定</p>
<h3 id="排序算法的使用场景"><a href="#排序算法的使用场景" class="headerlink" title="排序算法的使用场景"></a>排序算法的使用场景</h3><ol>
<li>游戏中得分排行榜</li>
<li>英雄战力榜列表等</li>
</ol>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>拓扑排序（Topological Sorting）是一种对有向无环图（Directed Acyclic Graph, DAG）进行排序的算法。在拓扑排序中，节点表示图中的任务或事件，有向边表示任务间的依赖关系。<br>拓扑排序的目标是将图中的节点按照一定的顺序线性排列，使得所有的依赖关系都得到满足。也就是说，在排序结果中，若存在一条从节点 A 到节点 B 的有向边，那么节点 A 在排序中必须出现在节点 B 之前。<br><strong>通俗讲解</strong>：当同时存在很多件事情需要完成，但是有些事情的完成依赖于另外若干件事情的完成，拓扑排序需要我们排列出事情完成的顺序，这个顺序往往不止一种。</p>
<p>拓扑排序的算法通常使用深度优先搜索（DFS）或广度优先搜索（BFS）来实现。在实际应用中，如果图中存在环路（即有向图中存在回路），则无法进行拓扑排序，因为无法满足所有的依赖关系。因此，拓扑排序算法通常要求应用于有向无环图。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>构建图：根据给定的有向图的边关系，构建表示图的数据结构。通常使用邻接表或邻接矩阵表示图。</li>
<li>统计节点入度：对于每个节点，统计它的入度（即指向该节点的边的数量）。可以通过遍历图的边关系，记录每个节点的入度。</li>
<li>初始化队列：创建一个队列（可以使用队列数据结构），用于存储入度为0的节点。</li>
<li>入度为0的节点入队：遍历所有节点，将入度为0的节点加入队列。</li>
<li>拓扑排序：从队列中取出一个节点，输出该节点（或保存到结果序列中），并将其相邻节点的入度减1。若某个节点的入度减为0，则将其加入队列。</li>
<li>重复步骤5，直到队列为空。如果输出的节点数量与图中的节点数量相同，则拓扑排序成功；否则，图中存在环路，无法进行拓扑排序。</li>
<li>输出结果：按照拓扑排序的顺序输出节点，即为拓扑排序的结果。</li>
</ol>
<pre class=" language-c++"><code class="language-c++">int topological_sort(LGraph G)
{
    int i,j;
    int index = 0;
    int head = 0;           // 辅助队列的头
    int rear = 0;           // 辅助队列的尾
    int *queue;             // 辅组队列
    int *ins;               // 入度数组
    char *tops;             // 拓扑排序结果数组，记录每个节点的排序后的序号。
    int num = G.vexnum;
    ENode *node;

    ins  = (int *)malloc(num*sizeof(int));  // 入度数组
    tops = (char *)malloc(num*sizeof(char));// 拓扑排序结果数组
    queue = (int *)malloc(num*sizeof(int)); // 辅助队列
    assert(ins!=NULL && tops!=NULL && queue!=NULL);
    memset(ins, 0, num*sizeof(int));
    memset(tops, 0, num*sizeof(char));
    memset(queue, 0, num*sizeof(int));

    // 统计每个顶点的入度数
    for(i = 0; i < num; i++)
    {
        node = G.vexs[i].first_edge;
        while (node != NULL)
        {
            ins[node->ivex]++;
            node = node->next_edge;
        }
    }

    // 将所有入度为0的顶点入队列
    for(i = 0; i < num; i ++)
        if(ins[i] == 0)
            queue[rear++] = i;          // 入队列

    while (head != rear)                // 队列非空
    {
        j = queue[head++];              // 出队列。j是顶点的序号
        tops[index++] = G.vexs[j].data; // 将该顶点添加到tops中，tops是排序结果
        node = G.vexs[j].first_edge;    // 获取以该顶点为起点的出边队列

        // 将与"node"关联的节点的入度减1；
        // 若减1之后，该节点的入度为0；则将该节点添加到队列中。
        while(node != NULL)
        {
            // 将节点(序号为node->ivex)的入度减1。
            ins[node->ivex]--;
            // 若节点的入度为0，则将其"入队列"
            if( ins[node->ivex] == 0)
                queue[rear++] = node->ivex;  // 入队列

            node = node->next_edge;
        }
    }

    if(index != G.vexnum)
    {
        printf("Graph has a cycle\n");
        free(queue);
        free(ins);
        free(tops);
        return 1;
    }

    // 打印拓扑排序结果
    printf("== TopSort: ");
    for(i = 0; i < num; i ++)
        printf("%c ", tops[i]);
    printf("\n");

    free(queue);
    free(ins);
    free(tops);
    return 0;
}</code></pre>
<p>其中G是有向图，结构可能如下：</p>
<pre class=" language-c++"><code class="language-c++">struct ENode
{
    int ivex;                   // 该边所指向的顶点的位置
    struct ENode *next_edge;    // 指向下一条弧的指针
} ;

struct VNode
{
    char data;                  // 顶点的数据
    ENode *first_edge;          // 指向第一条依附该顶点的边的指针
} ;

struct struct
{
    VNode vexs[MAX_VERTEX_NUM]; // 顶点数组
    int vexnum;                 // 顶点数量
    int edgenum;                // 边数量
} ;</code></pre>
<h2 id="操作系统和编译原理"><a href="#操作系统和编译原理" class="headerlink" title="操作系统和编译原理"></a>操作系统和编译原理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>概念：进程是操作系统分配资源的单位，线程是调度的基本单位，线程之间共享进程资源。</p>
<h4 id="进程如何分配线程和内存"><a href="#进程如何分配线程和内存" class="headerlink" title="进程如何分配线程和内存"></a>进程如何分配线程和内存</h4><p>进程是运行application的载体，客户端，服务器都是application，每个application会创建一个进程，在创建进程的时候，系统会在内存创建代码段，数据段，堆，栈。和其他三个不同，栈是每个线程独享的，其他三个是公共的。<br>代码段：进程会读取可执行文件（exe），这个文件本质上是操作CPU的二进制指令（程序编程成汇编语言之后最后会变成二进制的机器语言），这些指令在内核态就装载好了。然后进程就会至少创建一个主线程出来，可以基于这个线程创建更多线程，<strong>进程是线程的容器</strong>，然后线程调度CPU执行我们的任务（调度CPU是基于线程的），上面所说的就是进程创建代码段，代码段只能读取不能修改。二进制指令文件（exe)在内核态装载完成后，就会调到main入口（已经确定内置地址），开始执行第一条指令。<br>数据段：负责全局变量，单例中的静态变量等的存放。<br>堆：用来做动态内存分配，例如创建对象的时候就是在堆创建出来，系统会从堆上分配一个满足要求大小的内存。如果不用了需要主动调用系统的free API来释放内存，但很多编程语言都内置垃圾回收器（GC），判断这个数据对象是垃圾，所以会主动回收，但是这会消耗系统性能，所以我们才需要尽可能减少GC。</p>
<p>栈：每个线程有独立的栈，存放代码执行中函数的参数等局部变量，并为函数跳转，返回提供服务，原理是栈临时存储了函数中的变量或引用，并在这个函数的顶部入栈了一个函数的形参，返回地址，前一个栈底地址（%ebp），以便函数调用完成后恢复原来的地址，并设置栈底(%esp)为当前栈顶值，调用完成后返回值压入EAX（如果返回值超过EAX宽度，高位放在EDX中）中并恢复现场。栈的大小有限制（默认几十k，可修改），超出会导致栈溢出，导致系统杀掉进程。<br>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27161565/article/details/110210030">https://blog.csdn.net/qq_27161565/article/details/110210030</a></p>
<h4 id="虚拟内存和物理内存，动态内存分配"><a href="#虚拟内存和物理内存，动态内存分配" class="headerlink" title="虚拟内存和物理内存，动态内存分配"></a>虚拟内存和物理内存，动态内存分配</h4><p>每个进程都会创建一个虚拟内存空间，只有这个进程能够访问，不同进程就算修改同一地址，指向的也不是同一个内存。虚拟内存不代表分配了真实内存，只是划了一个范围。只有在实际用到的时候予以分配，系统会划出一段地址，分配一些物理内存页（例如4K为一个映射单元），如果内存页不够，就会把长期不用的保存到磁盘从而释放内存页，当需要使用磁盘中的内存页的时候再交换回来，但这样会导致系统开销变大，CPU占用率高。数据是保存到映射的物理页的。<br>内存释放的时候，先释放对应的虚拟内存空间，再释放物理内存页，这样就能给其他进程或这个进程的其他虚拟内存地址使用。<br>动态分配的时候，出现out of memory的错误，有两种情况，一种是虚拟内存都分配完了，第二种是关闭了物理内存的交互功能或操作系统不堪重负死机了。<br>Tips：进程可以创建另外一个进程，相当于把代码段，数据段，堆重新创建一遍，但是子进程能访问主进程的函数，这是因为它们映射到的是同一个物理内存页，除非装载了新的代码。</p>
<h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>内存碎片是对于堆来说的，只有堆的大小是动态的。<br>导致内存碎片的原因是反复请求与释放大小不一的内存空间，从而使得中间产生了很多段不能使用的空白内存。<br>解决方法：</p>
<ol>
<li>分配大小统一的内存空间</li>
<li>设定对象池，循环反复利用<h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4>概念：虚拟的可用的内存地址空间越来越少<br>原因：分配的内存空间没有任何指针指向，但是又没有释放。<br>解决方法：</li>
<li>C/C++传统方式：分配内存的时候提前想好释放时机，并写代码执行</li>
<li>采用系统托管的垃圾回收机制，拥有垃圾回收的语言所有的对象都继承自Object这样的东西，每当有赋值操作的时候（内部有重载），里面的引用计数就会+1，如果原来的变量=null，引用-1，引用计数为0的时候，调用系统的内存释放API。垃圾回收的时候，可以启用一个垃圾回收线程，也可以在主线程的特定时候调用。垃圾回收机制在内存分配的时候，看有没有同类型的垃圾对象，有的话直接返回，没有再申请内存</li>
</ol>
<p>追踪内存泄露：<br>内存泄露检测工具：原理是接管了分配释放内存的malloc,free函数，判断哪里调用了malloc但是没有free。</p>
<ol>
<li>手动管理：重载ne  w，delete，malloc的时候把对象添加到表中，free的时候从表中删除。如果一个对象长时间在表中，可能发生泄露</li>
<li>自动管理：由于代码逻辑问题，有变量指向一个内存，但是你没有发现。<br>tips：不断打开文件，忘记关闭也会导致系统越慢<h4 id="GC性能优化"><a href="#GC性能优化" class="headerlink" title="GC性能优化"></a>GC性能优化</h4></li>
<li>减少new的次数</li>
<li>调节GC参数，调节垃圾回收时机</li>
<li>避免GC峰值：避免大量消耗和创建对象，确实需要的时候可以分配处理（每帧处理少量） 。</li>
</ol>
<h4 id="操作系统如何调度线程"><a href="#操作系统如何调度线程" class="headerlink" title="操作系统如何调度线程"></a>操作系统如何调度线程</h4><p>操作系统需要分配CPU核心来执行线程的任务（代码指令），为了充分利用CPU资源，所谓的六核十二线程，一个CPU的物理核心模拟成两个逻辑核心，同时处理两个线程的任务（超线程技术）。<br>线程的两个状态：</p>
<ol>
<li>就绪状态：可被调度，放在就绪队列</li>
<li>挂起状态：等待某个条件对象，如文件IO结束，睡眠结束，操作系统不会调度这些线程</li>
</ol>
<p>Windows，Linux，Unix都是抢占式多任务管理系统：如果线程可以一直执行就一直占用CPU直到系统分配的时间片（根据线程的优先级分配）用完，然后才会放回就绪队列，等待重新被调度。<br>调度过程：CPU核心把此时寄存器的数据保存到内存中，然后从内存中读取要调度的线程上一次保存的寄存器数据，就能继续执行线程。<br>由于线程随时有可能被调度出去然后执行其他线程，所以一些全局变量有可能随时被修改。</p>
<p>系统调度线程的开销：</p>
<ol>
<li>内核决定哪个线程被调度</li>
<li>被调度出去的需要保存现场环境</li>
<li>重置调度进来的线程的现场环境</li>
</ol>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁是针对多线程编程而言。能保证线程安全。<br>同一个进程的线程之间共用数据段，堆，同时访问，使用的时候可能会发生冲突，所以需要加锁。加锁的时候，当其他线程想要操作加锁的对象的时候，我们让它挂起。直到这个锁被释放，线程才能处于就绪状态。<br>开销：</p>
<ol>
<li>线程切换的开销</li>
<li>影响并发的进度，所以有其他办法的话尽可能不用</li>
</ol>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>原因：多线程，因并发，导致了线程争用的安全问题<br>条件：互斥条件、不可剥脱条件、请求与保持条件、循环等待条件<br>说明：一个线程都保持着一个锁，但是又请求着另外一个锁住的资源。另外一个线程锁住了这个资源，同时请求原来线程锁住的资源。n个线程满足这种循环等待的条件即可形成死锁。<br>解决方法：</p>
<ol>
<li>请求锁的顺序要一致，并且后lock的先释放</li>
<li>不允许在占用一个资源的时候请求另外的资源</li>
<li>当请求资源被拒绝的时候要先释放自己占有的资源。</li>
</ol>
<h4 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h4><ol>
<li><p>文件通讯</p>
</li>
<li><p>socket通讯</p>
</li>
<li><p>管道通讯<br>管道：其实就是一个进程将数据写到内核中，另一个线程从内核中读取数据。</p>
</li>
</ol>
<ul>
<li>单向：无格式的流并且大小受限；先进先出；管道这种通信方式效率低，不适合进程间<br>频繁地交换数据；</li>
<li>匿名管道：匿名管道是只能用于存在父子关系的进程间通信</li>
<li>命名管道：可以在任何的进程之间使用，因为使用命名管道的前提，需要在文件系统创<br>建 个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信</li>
</ul>
<h4 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h4><p>共享数据，全局变量，堆<br>需要保证线程安全，保证唯一性，有必要的话要加锁</p>
<h3 id="地址、字节、内存对齐（感觉都差不多）"><a href="#地址、字节、内存对齐（感觉都差不多）" class="headerlink" title="地址、字节、内存对齐（感觉都差不多）"></a>地址、字节、内存对齐（感觉都差不多）</h3><h4 id="地址对齐"><a href="#地址对齐" class="headerlink" title="地址对齐"></a>地址对齐</h4><p>什么是地址对齐？<br>现代计算机中内存空间都是按照字节(byte)划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排列，这就是对齐。</p>
<p>为什么要地址对齐？<br>对 齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定的类型的数据只能从某些特定的地址开始存取。其它平台可能没有这些限 制，<strong>但是最常见是的如果不按照适合其平台的要求对数据存储进行对齐，会在存取效率上带来损失。</strong>比如有些平台每次读都是从偶数地址开始，如果一个 int 型（假设是 32 位）如果存放在偶数地址开始的地方，那么一个时钟周期就可以读出。而如果是存放在一个奇数地址开始的地方，就可能会需要 2 个时钟周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 型数据。显然在读取效率上下降很多。这也是空间和时间的博弈。</p>
<p>对齐的实现<br>通常,我们写程序的时候，不需要考虑对齐的问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变指定数据的对齐方式。但是，正因为我们一般不需要关心这个问题，又因为编译器对数据做了对齐处理。但我们不了解的话，常常会对一些问题感到迷惑。最常见的就是结构体(struct)的 sizeof() 结果，出乎意料。为此，我们需要对对齐算法有所了解。</p>
<h4 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h4><p>大多数计算机使用 字节（8 位的数据块）作为最小可寻址的存储器单位 ，而不是访问存<br>储器中单独的位。存储器的每一个字节都由唯一的数字标识，称为该字节的地址，所有可能地<br>址的集合称为存储器空间。<br>举例来说，ARM 处理器工作状态有如下两种：<br>l ARM 状态：执行字对齐的 32 位 ARM 指令。<br>l Thumb 状态：执行半字对齐的 16 位 Thumb 指令</p>
<h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><p>有些 CPU 可以访问任意地址上的任意数据，而有些 CPU 只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了<br>CPU 每次寻址都是要消费时间的，并且 CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐的内存，处理器需要做两次内存访问，而对齐的内存访问仅需要一次访问，内存对齐后可以提升性能。</p>
<h4 id="结构体的内存对齐规则"><a href="#结构体的内存对齐规则" class="headerlink" title="结构体的内存对齐规则"></a>结构体的内存对齐规则</h4><p>C 语言的对齐规则与 Go 语言一样，所以 C 语言的对齐规则对 Go 同样适用：</p>
<ol>
<li>对于结构体的各个成员，第一个成员位于偏移为 0 的位置，结构体第一个成员的偏移量(offset)为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。</li>
<li>除了结构成员需要对齐，结构本身也需要对齐，结构的长度必须是编译器默认的对齐长度和成员中最长类型中最小的数据大小的倍数对齐。</li>
</ol>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机为了解决跨平台的问题，每个平台对应的二进制指令模板不一样。<br>虚拟机负责读取字节码，解释执行，调用本地CPU硬件，我们编写的代码转换成字节码，加上虚拟机，就能在任意平台运行，不同的平台只需要生成不同虚拟机的runtime就可以了。<br>有两种类型：</p>
<ol>
<li>解释执行字节码（机器码），例如：Java虚拟机，.net虚拟机</li>
<li>直接解释代码，性能会差一些，例如：JS虚拟机</li>
</ol>
<p>虚拟机设计：</p>
<ol>
<li>定义虚拟机的字节码指令模板，设计寄存器架构，偏硬件</li>
<li>编写虚拟机的runtime程序，安装到目标平台（系统），或者随着app一起打包</li>
<li>定义一门编程语言，设计如何用其开发代码，并有配套的开发工具，一般提供垃圾回收。</li>
<li>制作编译工具，编译成字节码，由runtime来解释执行</li>
<li>提供SDK，例如：直接写好的代码，如何调系统接口等。</li>
</ol>
<p>Tips：虚拟机解释执行字节码，所以有性能问题</p>
<h4 id="web浏览器是如何实现的"><a href="#web浏览器是如何实现的" class="headerlink" title="web浏览器是如何实现的"></a>web浏览器是如何实现的</h4><ol>
<li>内置JS解释器（chrome —v10）</li>
<li>内置一个网页引擎（IE,webkit（chrome,safria））</li>
<li>定制浏览器界面（应用功能，设置功能）</li>
</ol>
<p>微信小游戏其实就是用web技术实现的游戏网页，微信app内置一个浏览器。</p>
<h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>运行解决：JIT(Just In Time)，虚拟机运行时检查代码性能，如果某段代码调用较多，运行时直接编译成机器码。</p>
<p>静态解决：运行之前解决，将影响性能的代码用native代码（C++）实现，然后用虚拟机调用。一般游戏引擎用C++控制OpenGL来渲染对象，再开放给脚本语言使用。也可以直接把字节码转换成native代码打包发布，但每个平台都需要打一个包。典型代表是Unity使用的IL2CPP，将.net字节码转换成C++代码再编译，从而获得更好的性能。</p>
<h4 id="IOS不支持虚拟机"><a href="#IOS不支持虚拟机" class="headerlink" title="IOS不支持虚拟机"></a>IOS不支持虚拟机</h4><p> IOS没有Java和.net的虚拟机，不允许热更新，不允许Flash。<br> 原因是虚拟机有成为平台的潜力，可以绕过苹果的审核，绕过苹果付费，影响苹果生态，同时也有不安全的问题。</p>
<h3 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h3><p>静态链接和动态链接是两种不同的链接方式，用于将程序的模块（如函数、库等）与程序主体进行连接，使得程序能够正确执行和运行所需的代码和数据。</p>
<p><strong>静态链接（Static Linking）：</strong><br>静态链接是指在编译时将所有的程序模块和库文件的代码和数据复制到最终的可执行文件中。在静态链接的过程中，编译器将程序所依赖的静态库文件的代码和数据全部复制到可执行文件中的特定部分，使得可执行文件成为一个完全独立的实体。当程序运行时，操作系统加载整个可执行文件到内存中，并直接执行其中的代码。</p>
<p>静态链接的特点：<br>可执行文件独立性高：可执行文件包含了所有需要的代码和数据，无需依赖外部的库文件。<br>执行速度相对较快：由于代码和数据已经全部包含在可执行文件中，程序的执行速度较快。<br>文件较大：由于静态链接会将所有模块和库文件的代码和数据都复制到可执行文件中，因此可执行文件的大小较大。</p>
<p><strong>动态链接（Dynamic Linking）：</strong><br>动态链接是指在程序运行时，程序所依赖的库文件的代码和数据并不被复制到可执行文件中，而是在需要时由操作系统动态加载到内存中，并与程序主体进行链接。在程序编译时，只会包含对库文件的引用，而不会将库文件的实际代码和数据包含在可执行文件中。</p>
<p>动态链接的特点：<br>共享库的重用性：多个程序可以共享同一个动态链接库（Shared Library），节省了系统资源和存储空间。<br>可执行文件较小：由于不包含所有库文件的代码和数据，可执行文件的大小较小。<br>运行时灵活性：动态链接使得程序在运行时可以动态加载和卸载库文件，增加了灵活性。<br>运行时依赖性：程序运行时依赖于所需的库文件，如果某个库文件缺失或版本不兼容，可能会导致程序无法运行。<br>需要注意的是，动态链接需要操作系统提供相应的支持，并且在程序运行时需要确保所依赖的库文件能够正确地被系统找到和加载。</p>
<h3 id="代码编写优化"><a href="#代码编写优化" class="headerlink" title="代码编写优化"></a>代码编写优化</h3><p>CPU指令缓存：CPU硬件内部有指令缓存，并非每次都需要从内存取指令执行，而是一次性取多条，这样速度会快得多。</p>
<p>CPU指令跳转：包括if，while,for,函数调用等。每次跳转的时候可能会打乱缓存，例如调用函数的时候要放弃原来的指令，重新装载函数内部的指令。这样会影响执行效率。</p>
<p>优化方法：</p>
<ol>
<li>性能核心的代码要尽量避免这些跳转，尽量顺序执行。</li>
<li>尽量把if else语句写到命中cache的部分，例如：执行if里面的代码的情况应该更多，跳转到else执行的情况应该更少。</li>
<li>for循环的时候也尽可能少写跳转与打断。</li>
</ol>
<p>函数调用开销：</p>
<ol>
<li>指令跳转开销</li>
<li>跳转之前，要保存栈的情况</li>
<li>传递参数会导致参数的拷贝</li>
<li>返回的时候要恢复栈的数据，要保存返回值</li>
</ol>
<p>优化原则是你需要证明这个地方存在性能问题，并且代码要优雅，不能为了优化而优化。</p>
<p>递归调用对函数调用的开销很大，如果问题规模很深很大容易栈溢出，但是写代码的逻辑简单。</p>
<p>系统设计要有鲁棒性，随着问题规模的增长，你的开销是稳定的，开销的变化，到了某个规模是无法承受的，递归是一种不稳定的开销。</p>
<h2 id="C-部分"><a href="#C-部分" class="headerlink" title="C#部分"></a>C#部分</h2><h3 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h3><p>程序集（Assembly）是在 .NET Framework 和 .NET Core 等微软的托管环境中使用的基本部署单元。它是一种逻辑和物理上的封装，用于组织、版本控制、部署和执行代码。</p>
<p>程序集包含了执行特定任务所需的所有代码（包括可执行代码、类型定义、资源、元数据等），并提供了一种将代码组织为逻辑单元的机制。在 .NET 环境中，程序集是面向对象的，可以包含一个或多个相关的类型。</p>
<p>程序集有两种类型：<br>可执行程序集（.exe）：包含一个入口点（Entry Point），可以直接运行。当你启动一个可执行程序时，操作系统会加载该程序集，并执行其中的入口点。<br>动态链接库（.dll）：是一个可被其他程序引用和调用的代码模块。它可以包含各种可被其他程序共享使用的类型、方法和资源。</p>
<p>程序集还包含元数据，其中包括有关类型、成员、引用和其他相关信息的描述。这些元数据使得程序集具有自描述的特性，使得在运行时能够进行反射和动态加载。<br>程序集还支持版本控制和部署。通过为程序集指定版本号，可以确保在更新程序集时，应用程序能够正确地使用所需的版本。程序集可以被部署到本地文件系统、Global Assembly Cache (GAC)、网络位置等。</p>
<h3 id="抽象函数和虚函数的区别"><a href="#抽象函数和虚函数的区别" class="headerlink" title="抽象函数和虚函数的区别"></a>抽象函数和虚函数的区别</h3><ol>
<li>抽象方法是只有方法名称，没有方法体，即没有方法的具体实现，子类必须重写父类抽象方法才能实现具体功能；虚函数有方法名称也有方法体，但是子类可以覆盖，也可不覆盖。</li>
<li>抽象方法是一种强制派生类覆盖的方法，否则派生类将不能被实例化。</li>
<li>抽象方法只能在抽象类中声明，虚方法不是。</li>
</ol>
<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><ol>
<li>重载在同类中，重写在父子类中</li>
<li>重载和重写虽然方法名一样，但是重载参数列表不同，重写相同</li>
<li>重载是相同对象以不同参数调用，重写是不同对象以相同参数调用</li>
<li>重载编译时多态，重写运行时多态</li>
</ol>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>C# 的垃圾回收器基于“代”的概念，使用了分代垃圾回收策略。具体的垃圾回收过程如下：</p>
<p>分代堆：堆被划分为三个代：0代、1代和2代。新创建的对象首先分配在0代中，如果经过一次垃圾回收后仍然存活，将被提升到下一代。这样，较新的对象更有可能被回收，而存活更久的对象则会逐渐晋升到更高的代中。</p>
<p>标记阶段：垃圾回收器从根对象（如全局变量、活动线程栈中的引用）开始，通过可达性分析算法（通常是使用标记-清除算法或标记-整理算法），遍历对象图，并标记所有可达的对象。被标记的对象将被视为存活对象。</p>
<p>清除阶段：在标记阶段之后，垃圾回收器会遍历堆中的所有对象，清除未被标记的对象。被清除的对象所占用的内存将被回收，并可以再次用于分配新的对象。</p>
<p>压缩阶段（可选）：在某些情况下，垃圾回收器可能会执行压缩操作。在压缩阶段，存活的对象将被整理，使它们在内存中连续排列，以便更好地利用内存空间。</p>
<h3 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h3><p>装箱：装箱就是把值类型转换为 object 类型或由此值类型实现的任何接口类型<br>拆箱：就是把装箱后的引用类型转换为值类型</p>
<p>装箱和拆箱操作会引入一定的性能开销，因为涉及数据的复制和类型转换。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是一种迭代器，每执行一次返回一个值，yield是语法糖，会生成实际的迭代器类。第一个yield是第一个状态，第二个yield是第二个状态。</p>
<p>迭代器：里面包含一个个包含返回值函数，迭代器依次执行每一个函数，把返回值存到一个Current变量中。每一次执行迭代器的MoveNext方法，就会执行一个函数，并把位置移到下一个函数。<br>yield：每一个yield相当于给迭代器增加一个函数，函数的内容是这一个yield到上一个yield之前的部分。</p>
<p>在Unity中，协程每次在LateUpdate的时候被调用。所以代码逻辑太过复杂的时候会卡住主线程。<br>自己实现协程：</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ClassWaitForTime</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">float</span> total<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">float</span> now<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">ClassWaitForTime</span><span class="token punctuation">(</span><span class="token keyword">float</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>total <span class="token operator">=</span> time<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token keyword">float</span> dt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>now <span class="token operator">+</span><span class="token operator">=</span> dt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">isOver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>now <span class="token operator">>=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>total<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Game</span> <span class="token punctuation">:</span> MonoBehaviour <span class="token punctuation">{</span>

    <span class="token keyword">private</span> IEnumerator e <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    IEnumerator <span class="token function">start_Coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"1111111111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Hellword"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>

        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"我要睡5秒，别叫醒我"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ClassWaitForTime</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"我醒了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">yield</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 终止结束了； </span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// Use this for initialization</span>
    <span class="token keyword">void</span> <span class="token function">Start</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">this</span><span class="token punctuation">.</span>e <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">start_Coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token preprocessor property">#<span class="token directive keyword">if</span> TEST</span>
        <span class="token comment" spellcheck="true">// step1 创建一个IEnumerator</span>
        IEnumerator e <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">temp_Coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// step2: 启动一个协程</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">StartCoroutine</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token preprocessor property">#<span class="token directive keyword">endif</span></span>

    <span class="token punctuation">}</span>


    IEnumerator <span class="token function">temp_Coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"i = "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// yield return null; // 终止协程，只到下一个帧开始;</span>
            <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WaitForSeconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 终止协程，只到2秒结束以后再继续执行</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// Update is called once per frame</span>
    <span class="token keyword">void</span> <span class="token function">Update</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">LateUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>e<span class="token punctuation">.</span>Current <span class="token keyword">is</span> ClassWaitForTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              ClassWaitForTime wt <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>e<span class="token punctuation">.</span>Current <span class="token keyword">as</span> ClassWaitForTime<span class="token punctuation">;</span>
              wt<span class="token punctuation">.</span><span class="token function">Update</span><span class="token punctuation">(</span>Time<span class="token punctuation">.</span>deltaTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isOver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果时间没有到，你就不要往后面执行了;</span>
              <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>

          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>e<span class="token punctuation">.</span><span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">this</span><span class="token punctuation">.</span>e <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>Unity协程应用：<br>自定义一个协程，只需要新增一个 class，继承自 CustomYieldInstruction 并实现 KeepWating</p>
<pre class=" language-csharp"><code class="language-csharp">IEnumerator <span class="token function">Do2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//Unity中每帧调用一次</span>
  <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WaitForMouseButtonDown</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里可以不new,找对象池要一个，优化性能</span>
  Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitForMouseButtonDown</span><span class="token punctuation">:</span> CustomYieldInstruction<span class="token comment" spellcheck="true">//自定义协程基类</span>
<span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> curr<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> max<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token function">WaitForMouseButtonDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>max <span class="token operator">=</span> max<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">bool</span> keepWaiting <span class="token operator">=</span><span class="token operator">></span> <span class="token function">CheckState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">CheckState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>curr <span class="token operator">>=</span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"达到点击次数"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>Input<span class="token punctuation">.</span><span class="token function">GetMouseButtonDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        curr <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>；
        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"点击了一次鼠标"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="类和对象的内存占用"><a href="#类和对象的内存占用" class="headerlink" title="类和对象的内存占用"></a>类和对象的内存占用</h3><p>一个类被实例化后，就会开辟一块内存存放数据成员，这块空间不仅包括数据本身的大小，而且包括编译器数据对齐的消耗，对象头。而它的成员函数并不是这个时候放在内存的，而是一开始就放在代码段中，并且会记录这个函数在代码段的位置（偏移）</p>
<p>对象头包括两部分信息：</p>
<ul>
<li>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位的虚拟机（未开启压缩指针） 中分别为32个比特（4字节）和64个比特（8字节），但8个字节只有后面4个字节会被使用</li>
<li>另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li>如果对象是一个 java 数组，那么在对象头中还有一块用于记录数组长度的数据。</li>
</ul>
<p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。而且编译器会知道每个数据相对于对象实例地址的偏移。</p>
<p>对齐填充起着占位符的作用。 由于很多64位虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。 对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话， 就需要通过对齐填充来补全。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>C#反射是一种功能强大的机制，它允许程序在运行时动态地检查类型、访问和操作类型的成员（如字段、方法、属性等），以及创建、使用和销毁对象，而无需事先知道这些类型的具体信息。</p>
<p>任意一个类，包括我们自己定义的类，都可以转换为这样一种描述：</p>
<ol>
<li>内存块大小，和数据成员有关</li>
<li>类的数据成员的信息，通过数组等其他形式保存：<br>{“age”,type int,偏移0个字节}<br>{“sex”,type int,偏移1个字节}<br>{“name”,type string,偏移8个字节}</li>
<li>类的成员函数：<br>{“func1”, type 成员函数（静态）, 代码段偏移}<br>{“func2”, type 成员函数, 代码段偏移}<br>{“func3”, type 成员函数, 代码段偏移}</li>
</ol>
<p>编译的时候，每个类都会生成这样的描述实例（Type类型）来存这些信息，这些信息存入.exe文件。然后底层就可以根据这些信息构建类的实例，调用方法和成员了。<br>实例化的时候，底层就会根据信息分配内存块大小，然后调用构造函数（也在描述中）。<br>这个过程其实叫反射。</p>
<p>实际运用的时候，获取这样的描述实例的方式很简单，调用API即可：<br>Type t = System.Type.GetType(“类型的名字”)<br>Type t = typeof(T)<br>这个Type实例中包含着数据成员信息FieldsInfos，成员函数信息MethodInfos。然后我们根据这个Type实例就能通过反射创建一个对象：</p>
<pre class=" language-csharp"><code class="language-csharp">instance <span class="token operator">=</span> Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>由于Type里面已经储存了数据成员的偏移，大小，所以可以从对象的内存中读取，设置成员的数据。</p>
<pre class=" language-csharp"><code class="language-csharp">FieldInfo<span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">GetFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
FieldInfo ageInfo <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">GetField</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ageInfo<span class="token punctuation">.</span><span class="token function">SetValue</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 设置数据成员</span>

MethodInfo m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">GetMethod</span><span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> funcParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">System<span class="token punctuation">.</span>Object</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
funcParams<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
funcParams<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
funcParams<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"good"</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>Object ret <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span>funcParams<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行对应成员函数，获取返回值</span></code></pre>
<p>反射的价值在于用统一的方式处理任意的类型，任意新建的类都可以调用到，可以同同一种方式创建所有类的实例，而不用在底层做修改。</p>
<h2 id="Unity部分"><a href="#Unity部分" class="headerlink" title="Unity部分"></a>Unity部分</h2><h3 id="Unity底层如何处理C"><a href="#Unity底层如何处理C" class="headerlink" title="Unity底层如何处理C#"></a>Unity底层如何处理C#</h3><p>重点：.net，Mono，IL2CPP</p>
<p>Unity的历史里为什么会选择Mono?<br>Mono是微软在.net标准开放以后，开发的一个跨平台的.net项目，Unity使用Mono来开发游戏引擎，打包发布我们的游戏产品app，也具有跨平台的特性，为了这个特性而使用了Mono</p>
<p>为什么Unity后来选择了IL2CPP？</p>
<ol>
<li>基于.net的Mono具有版权的问题</li>
<li>Mono虚拟机解释执行.net字节码，存在一定的效率问题</li>
<li>有些平台（IOS）不允许内置mono .net虚拟机。</li>
<li>如果出现新的平台，mono不支持，Unity就失去了部分的跨平台能力，并且如果自己动手也不好移植，会与Mono的主干分开，维护麻烦。</li>
</ol>
<p>IL2CPP的优势？<br>概念：IL指的是.net字节码，cpp指的是C++代码，这项技术可以把.net字节码转换为C++的代码（里面包含了C++没有的垃圾回收等支持），然后通过开发一个跨平台的Runtime和对应的工具一起编译来生成对应目标平台的应用程序。因此我们开发的时候还是用Mono，但是打包发布的时候使用的是IL2CPP。因为通过各个平台的C++编译器直接生成了机器码，也就是在你发包的时候已经是机器码了，所以很快。</p>
<p>好处：</p>
<ol>
<li>解决了跨平台可移植问题，解决了.net版权问题</li>
<li>运行效率获得提升</li>
</ol>
<h3 id="为什么-Unity-中很少用多线程？多线程和协程都是非阻塞的，两者的优劣？"><a href="#为什么-Unity-中很少用多线程？多线程和协程都是非阻塞的，两者的优劣？" class="headerlink" title="为什么 Unity 中很少用多线程？多线程和协程都是非阻塞的，两者的优劣？"></a>为什么 Unity 中很少用多线程？多线程和协程都是非阻塞的，两者的优劣？</h3><p>协程依然运行在主线程，只是逻辑上是非阻塞的而已。Unity 引擎本身是多线程的，只是 C#脚本是运行在同一个线程中的。因为游戏引擎是主循环结构，逻辑更新和画面更新时间点要求有确定性，如果逻辑更新和画面更新中引入了多线程，就需要做同步，而这加大了游戏的开发难度。</p>
<h3 id="Unity-的内存分配机制"><a href="#Unity-的内存分配机制" class="headerlink" title="Unity 的内存分配机制"></a>Unity 的内存分配机制</h3><p>Unity 实际上可以看作是一个使用 C++开发的游戏引擎，它使用.net 的脚本虚拟机。Unity 从虚拟内存中给原生（C++）对象和虚拟机分配内存，同样，第三方插件的内存分配也都是在虚拟内存池中。原生内存（Native Memory ）是虚拟内存的一部分，它用来给所有需要的对象分配内存页面，包括 Mono 堆（Mono Heap）。如上所说，Mono 堆是出于虚拟机的需要而专门分配的本机内存的一部分。它包含了所有由 C#分配的托管的内存类型，而这些内存的托管对象就是垃圾收集器（Garbage Collector），简称 GC。</p>
<p>Unity 内部有几个专门的分配器，它们负责管理虚拟内存的短期和长期分配需求。所有的 Unity 资产（Assets）都是存储在原生内存中的。但这些资产会被轻量的包装成 Class，以供逻辑访问和调用。也就是说，如果我们用 C#创建了一张Texture，那么它的大部分原始数据（RawData）存在于 Native 内存中，并且会有很小的一个 Class 对象进入到虚拟机中，也就是 Mono 堆中。</p>
<h3 id="死锁会因为资源抢占引起，说说-unity-有哪些资源"><a href="#死锁会因为资源抢占引起，说说-unity-有哪些资源" class="headerlink" title="死锁会因为资源抢占引起，说说 unity 有哪些资源"></a>死锁会因为资源抢占引起，说说 unity 有哪些资源</h3><p>死锁这里的资源占用，是指一切对象<br>Unity 中的资源有：GameObject、Component、AudioClip、AnimationClip、AniamtionController、各种 Asset</p>
<h3 id="unity-是怎么管理-resources-的"><a href="#unity-是怎么管理-resources-的" class="headerlink" title="unity 是怎么管理 resources 的"></a>unity 是怎么管理 resources 的</h3><p>Resources 本质上就是一个默认 Assetbundle，Resources 文件夹下的文件都会打入整个 AB 包，并且在游戏启动时就加载整个 AB 包</p>
<h3 id="NGUI-UGUI-渲染顺序"><a href="#NGUI-UGUI-渲染顺序" class="headerlink" title="NGUI UGUI 渲染顺序"></a>NGUI UGUI 渲染顺序</h3><p>不同的 Camera 的 Depth，值越大越后渲染<br>相同 Camera 下的不同 SortingLayer<br>相同 SortingLayer 下的不同 Z 轴/Order in Layer<br>Camera 模式下渲染顺序：基于同 Layer 同 OrderInLayer，因为渲染顺序优先级是：camera 的 depth&gt;Layer&gt;OrderInLayer&gt;Z 轴，注意 UI 的渲染顺序最后是<br>OrderInLayer&gt;transform 的层级</p>
<h3 id="如何用-NavMesh-动态寻路"><a href="#如何用-NavMesh-动态寻路" class="headerlink" title="如何用 NavMesh 动态寻路"></a>如何用 NavMesh 动态寻路</h3><p>（1）烘焙导航网格<br>（2）需要导航的物体添加 NavMeshAgent 组件<br>（3）运行时候使用 NavMeshAgent.SetDestination 函数进行导航</p>
<h3 id="profiler与stats"><a href="#profiler与stats" class="headerlink" title="profiler与stats"></a>profiler与stats</h3><h4 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h4><p>点开Unity Game窗口中的stats可以看到游戏运行时的参数：<br>重要参数：<br>Graphics：<br>  CPU：主逻辑消耗时间<br>  render thread：渲染消耗时间<br>  Batches：场景中的物体分几批绘制，每次绘制需要一个drawCall<br>  Saved by batching：被合批到一起的总物体数，由显卡决定，显卡越好，能够一次性合批在一起的物体数越多。<br>  Tris：总绘制的面数<br>  Verts：总绘制的顶点数<br>  Screen：屏幕分辨率，占用内存<br>  SetPass Call：配置渲染管道的shader等参数的次数，非常消耗性能。<br>  Shadow Casters：阴影开销，打开阴影会增大batches，main，render thread。<br>  Visable Skinned Meshes：人物的蒙皮网格数量。<br>  Animation：动画数量。</p>
<h4 id="Profiler"><a href="#Profiler" class="headerlink" title="Profiler"></a>Profiler</h4><p>打开方式：Ctrl+7<br>点击CPU Usage:<br>上面是一副曲线图，绘制了每个时刻代码，物理引擎，渲染等消耗</p>
<p>下面的表格从高到低列举了调用某个函数的耗时，Total指整个函数的耗时百分比，而Self指的是除了调用其他函数的部分的耗时百分比，Calls指的是每一帧调用这个函数的次数，函数举例：<br>WaitForTarget：CPU休眠的时间<br>Camera Render：渲染时间<br>OverHead：不明确的时间消耗。<br>Behaviour Update：Update函数的时间消耗<br>GUI Paint：OnGUI函数的时间消耗</p>
<p>点击Rendering，下面会显示对应的渲染参数：<br>上面会显示三种合批方式，参数如下：<br>Batched Draw Calls：合批的个数<br>Batches：分为多少批</p>
<p>点击Memory显示的是内存相关信息</p>
<h3 id="动态批，静态批，GPU-Instancing合批"><a href="#动态批，静态批，GPU-Instancing合批" class="headerlink" title="动态批，静态批，GPU Instancing合批"></a>动态批，静态批，GPU Instancing合批</h3><p>静态批：游戏引擎会将能够合批的(同一个材质球)标记为静态的物体合批到一起，提交给GPU。游戏引擎会预先合并静态物体的网络，提交给GPU。因为静态批会增加合并后的内存开销，有的情况我们必须关闭静态批，例如渲染1000颗树，如果合批，网格会导致内存暴涨。静态批通过预处理阶段合并顶点数据，并生成新的合并后的网格。在Project Setting中开启。</p>
<p>动态批：CPU计算能合批频繁变化物体（材质相同）的网格，然后提交给GPU绘制，相当于给动态合批的物体重新建模。动态批会消耗CPU性能。动态合批是引擎自动处理的，引擎会有一个顶点数量的限制。动态批需要在运行时动态合并，并在每帧或每次渲染前进行数据传输。在Project Setting中开启。</p>
<p>GPU Instancing合批：允许多个相同的渲染对象在GPU上以单个渲染调用的形式进行渲染。提交一个物体，GPU能绘制N个实例到不同的位置。每一批能够绘制的数目和GPU性能相关。可以在Shader中开启。</p>
<h3 id="Unity是如何绘制3D物体"><a href="#Unity是如何绘制3D物体" class="headerlink" title="Unity是如何绘制3D物体"></a>Unity是如何绘制3D物体</h3><p>每一个模型都由无数个面构成，每一个面都是三角形，每一个形状的面都能分成若干个三角形，而三角形由三个顶点构成。</p>
<ol>
<li>顶点初始化，CPU把模型的顶点数据（位置，法线，纹理坐标…）放到GPU</li>
<li>顶点shader做坐标变换，把模型数据变换到世界坐标，再变换到以摄像机为基准的坐标系。</li>
<li>从摄像机的角度绘制画面，相当于在摄像机的位置摆放一个手电筒，然后在物体背后的一面墙上成像。墙到摄像机的距离固定，我们需要通过物体的三维坐标计算二维的投影点，这是一个数学问题。</li>
<li>在把模型的三角形面投影到2D之后，再把三个顶点的颜色做插值，然后给三角形内部按照这个插值上色填充。</li>
</ol>
<p>我们可以编写代码进行干预的是顶点shader和片源着色shader。</p>
<h4 id="MeshRenderer-SkinnedMeshRenderer绘制3D物体流程"><a href="#MeshRenderer-SkinnedMeshRenderer绘制3D物体流程" class="headerlink" title="MeshRenderer/SkinnedMeshRenderer绘制3D物体流程"></a>MeshRenderer/SkinnedMeshRenderer绘制3D物体流程</h4><ol>
<li>MenshRenderer会找到MeshFilter组件，把顶点数据装载的内存</li>
<li>MenshRenderer装载配置好shader，材质，渲染管道。</li>
<li>MenshRenderer绘制的时候需要将内存的顶点数据放到显存</li>
<li>MenshRenderer提交变化矩阵相关数据，材质中的数据给shader</li>
</ol>
<p>动画组件就是根据动画文件来改变模型的顶点，从而改变模型的形状。</p>
<p>SetPass Call是配置渲染管道的shader等参数的次数，非常消耗性能。跟shader数目有关，也跟分批绘制情况有关，我们需要把同一个shader绘制的物体给分到同一批绘制，从而减小SetPass Call。</p>
<h4 id="千人战场性能优化"><a href="#千人战场性能优化" class="headerlink" title="千人战场性能优化"></a>千人战场性能优化</h4><ol>
<li>阴影关掉</li>
<li>选择modile里面性能比较好的shader</li>
<li>把SkinnedMeshRenderer转换成MeshRenderer，需要用到 AnimMapBaker插件，连动画组件都能优化掉，使用shader来实现动画的效果。这个工具只支持Animation动画。原理是通过离线采用，将每一帧的顶点位置存到贴图中。通过shader播放出来。</li>
<li>开启instancing合批，限制比较宽松，但不支持SkinnedMeshRenderer，每个shader都有，勾选上就行。同一个shader，同一个网格，参数可以不一样，就能合批。根据GPU的性能来决定分批的数量（因为GPU每一次绘制的三角形数目有上限）</li>
</ol>
<p>Tips：有两个DrawCall是系统自带的，代表天空盒和清理屏幕。其他的才是我们的物体决定。</p>
<h3 id="DrawCall优化"><a href="#DrawCall优化" class="headerlink" title="DrawCall优化"></a>DrawCall优化</h3><p>概念：游戏场景的物体，CPU分几批提交给GPU绘制，就有几个DrawCall，Unity Game窗口中Stats下的Batches属性就是DrawCall的数量。默认有背景和天空盒两个DrawCall。<br>分析：隐藏节点，观察DrawCall的变化。</p>
<h4 id="UGUI的DrawCall"><a href="#UGUI的DrawCall" class="headerlink" title="UGUI的DrawCall"></a>UGUI的DrawCall</h4><p>UGUI影响两个物体合批的条件：</p>
<ol>
<li>模型是否相同（矩形）</li>
<li>shader是否相同（UI/Default）</li>
<li>纹理参数是否相同（Image）<br>一般1，2点容易满足，主要在第三点。<br>解决方法：<br>把小图片资源做成一张图集（整图）。</li>
<li>点击Edit-&gt;Project Settings-&gt;Editor-Sprite Packer，里面的Mode调节为Always Enabled。</li>
<li>新建一个图集的名字tag（在图片属性里面设置Packing Tag），把需要打包的图片放到一个文件夹下，以文件夹的名字作为图集名字</li>
<li>Window-&gt;Sprite Packer，点击Pack，就能看到图集，图集在Library文件夹中的AtlasCache中。</li>
</ol>
<p>UGUI合批之后，合批的数量不会统计在Saved by batching内。</p>
<h4 id="Text对DrawCall的影响"><a href="#Text对DrawCall的影响" class="headerlink" title="Text对DrawCall的影响"></a>Text对DrawCall的影响</h4><ol>
<li>和图片不同，Text的纹理图集是不一样的。但是，在运行的时候会根据文字的内容生成文字图集，所以看起来文字很多且不同，但实际上都在一个图集里面。</li>
<li>Unity在不影响层级关系的情况下，合并text的DrawCall（即使文字打乱了图片的DrawCall）。但是有的时候按照场景树来说，我们设定的文字打乱drawCall，并且影响了层级关系，Unity就不能帮我们合并drawCall。</li>
<li>如果字体库不一样，DrawCall也会增加。</li>
</ol>
<h4 id="Image和RawImage"><a href="#Image和RawImage" class="headerlink" title="Image和RawImage"></a>Image和RawImage</h4><p>Image优点：简单，并且可以合并DrawCall，但不能修改UV。UV参数可以调节图片显示的部分。<br>RawImage优点，可以修改纹理贴图的UV，但是即使图片在一个图集也不能合并DrawCall。</p>
<h4 id="OnGUI对DrawCall的影响"><a href="#OnGUI对DrawCall的影响" class="headerlink" title="OnGUI对DrawCall的影响"></a>OnGUI对DrawCall的影响</h4><p>OnGUI每绘制一个文本或图片，DrawCall都会增加1（同一个图集不能合批），且非常消耗性能。</p>
<h3 id="Mask和RectMask2D"><a href="#Mask和RectMask2D" class="headerlink" title="Mask和RectMask2D"></a>Mask和RectMask2D</h3><p>区别1:Mask主要处理不规则图形遮罩效果，RectMask2D只能做矩形遮罩.<br>区别2:Mask需要一个Image来当作遮罩区域,子节点在Image渲染区域才会显示，RectMask2D以自身RectTransform为裁剪区域,子节点在RectTransform区域内显示<br>区别3：性能优势，Mask导致的2个drawcall, 而RectMask2D只会在显示图片上有一个drawcall，本身不会有drawcall。<br>Tips：渲染层级、材质相同，纹理相同的才能合批，如果两个UI重叠，那么不属于一个层级</p>
<h4 id="mask底层"><a href="#mask底层" class="headerlink" title="mask底层"></a>mask底层</h4><p>通过渲染器（Renderer）和模板缓冲区（Stencil Buffer）实现<br>gpu为每个像素点分配一个称之为stencil buffer的1字节大小的内存区域，这个区域可以用于保存或丢弃像素的目的。</p>
<p>当一个UI元素包含了Mask组件时，它会在渲染时将自己的遮罩范围绘制到模板缓冲区中，同时禁用裁剪。遮罩范围使用模板缓冲区中的特定值来表示，可以看作是一个临时的遮罩层。在绘制其他UI元素时，会检查模板缓冲区的值。如果当前像素位于遮罩范围内，就继续渲染；否则，将该像素裁剪掉。在完成遮罩元素的渲染后，还原裁剪状态，以便正常渲染后续的UI元素。</p>
<h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><h4 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式"></a>压缩格式</h4><h4 id="纹理尺寸"><a href="#纹理尺寸" class="headerlink" title="纹理尺寸"></a>纹理尺寸</h4><p>约束：单个散图超过 512像素，不打图集，图集最大2048像素的尺寸<br>打图集的约束<br>注意合理划分纹理尺寸的大小比如说: 能用 512*512尺寸的搞定的，就不要使用 1024 * 1024，处理不当内存翻4倍</p>
<h4 id="MipMap"><a href="#MipMap" class="headerlink" title="MipMap"></a>MipMap</h4><h4 id="Read-Write逐像素可修改的参数"><a href="#Read-Write逐像素可修改的参数" class="headerlink" title="Read/Write逐像素可修改的参数"></a>Read/Write逐像素可修改的参数</h4><h3 id="图集有什么用"><a href="#图集有什么用" class="headerlink" title="图集有什么用"></a>图集有什么用</h3><ol>
<li>减少渲染批次：在游戏或应用程序中，渲染大量单独的图片会增加渲染调用的次数，从而影响性能。通过将多个图片打包到一个图集中，可以减少渲染批次，因为可以同时渲染图集中的多个图片，从而提高渲染效率。</li>
<li>减小内存开销：单独的图片文件需要存储文件头、元数据等信息，而每个图集只需要存储一份这些信息，可以大大减小内存开销。此外，图集还可以通过使用图片压缩算法来减小存储空间。</li>
<li>提高纹理显存利用率：图集中的图片在显存中是连续存储的，这样可以提高纹理显存的利用率。相比于单独的图片，图集可以更高效地利用显存，并减少显存碎片化。</li>
<li>方便管理和使用：使用图集可以更方便地管理和使用游戏或应用程序中的图片资源。在游戏开发中，可以使用图集编辑器工具将多个相关的图片打包成一个图集，并为每个图片指定在图集中的位置信息（如纹理坐标），便于在游戏中使用。</li>
<li>支持动画和精灵表：图集常用于创建动画和精灵表。通过在一个图集中按顺序排列不同帧的图片，可以实现动画效果。而精灵表是一个包含游戏中各种角色、道具、UI元素等的图集，通过切换显示不同的图集区域来实现不同元素的渲染。</li>
</ol>
<h3 id="描述游戏动画有几种，以及其原理"><a href="#描述游戏动画有几种，以及其原理" class="headerlink" title="描述游戏动画有几种，以及其原理"></a>描述游戏动画有几种，以及其原理</h3><p>主要有关节动画、单一网格模型动画(关键帧动画)、骨骼动画。<br>关节动画把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整<br>体的动画，角色比较灵活 Quake2 中使用了这种动画。<br>单一网络模型动画由一个完整的网格模型构成， 在动画序列的关键帧里记录各个顶点的原位<br>置及其改变量，然后插值运算实现动画效果，角色动画较真实。<br>骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的<br>层次结构，由关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观。<br>皮肤网格每一个顶点都会受到骨骼的影响，从而实现完美的动画。（骨骼动画是由关节动画<br>发展而来的，如今基本都使用骨骼动画来实现角色动画）</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>这部分内容可以参考：MMORPG-Part4，特别是资源优化部分<br>这一部分的知识点，在Unity、操作系统与编译原理章节有所涉及，这里会做更系统的描述：<br>性能优化，主要聚焦在 内存、 CPU、GPU 三大方向上。 粗略划分：<br>（1）内存：资源内存占用、引擎模块自身内存占用、托管堆内存占用等<br>（2）CPU：引擎模块性能开销、自身代码开销<br>（3）GPU: OverDraw、显存带宽等 优化方案</p>
<h3 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h3><p>性能优化方向：内存占用、大小容量、运行效率</p>
<h4 id="资源优化是首要优化任务"><a href="#资源优化是首要优化任务" class="headerlink" title="资源优化是首要优化任务"></a>资源优化是首要优化任务</h4><p>资源精细程度适可而止，不要占用太大空间，满载需求即可。<br>基础类型：模型、动作、纹理、声音、字体<br>综合资源类型：场景（地形、光影）、UI(图集)、粒子系统<br>其中基础资源前三个是优化重点<br>方法：<br><strong>制作前要指定合理规范</strong>：例如规定模型最大面数、UV、LOD，规定贴图最大尺寸和格式，动作时长帧率。其中一些基本规范为美术风格（写实、卡通、像素），视角（2D、3D、2.5D、固定、自由），场景（无缝大地图、超大规模）、玩法。使用九宫格、图集等。<br><strong>使用规范</strong>：模型导入优化（模型压缩、网格优化、可读写、Lightmap UV、动作导入）、动作导入优化（动画压缩、Rig-优化游戏对象）、纹理导入优化（纹理格式、POT、可读写、Mipmap、纹理大小、压缩选项）、场景优化（资源组织、引用和依赖、资源复用）、多平台优化（Standalone、IOS、Android）<br><strong>优化流程自动化</strong>：使用代码进行检查</p>
<h5 id="模型资源"><a href="#模型资源" class="headerlink" title="模型资源"></a>模型资源</h5><p>检查参数<br>Model选项卡中：<br>MeshCompression：网格压缩，减少模型精度来降低大小，启动压缩后每个模型看看有没有问题，没有问题可以打开<br>Read/Write Enable：可以读写，如果代码没有对模型进行读写可以关闭。<br>Optimze Mesh：优化网格<br>Rig选项卡：<br>Optimize Game Objects：可以优化模型中的子物体数量，可以变成一个，大大减小遍历时间。<br>Animation选项卡：<br>Import Animation：不带动画不要选，否则产生冗余消耗。<br>Anim Compression：动画压缩，可能会使动画出现问题，出现问题就关掉</p>
<h5 id="纹理资源"><a href="#纹理资源" class="headerlink" title="纹理资源"></a>纹理资源</h5><p>导入前图片格式要对：Png、TGA等，否则不支持转换成UI资源，导致没有办法压缩。<br>Max Size：设置图片最大尺寸<br>Compression：可以压缩图片，一般选High Quality<br>Compressor Quality：如果没问题就往小的调<br>Generate MipMaps：没有特殊情况保持打开，这样在距离较远时图片的像素会变小<br>注意：NPOT和POT的占用大小完全不同</p>
<h4 id="代码处理"><a href="#代码处理" class="headerlink" title="代码处理"></a>代码处理</h4><p>Unity有一个AssetPostprocessor类，可以继承它进行处理，具体查资料。</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span>
<span class="token keyword">using</span> UnityEditor<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>IO<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> PostProcessor<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UTexturePreprecessor</span><span class="token punctuation">:</span> AssetPostprocessor<span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">bool</span> IsHD <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>

        <span class="token keyword">void</span> <span class="token function">OnPreprocessTexture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            TextureImporter textureImporter <span class="token operator">=</span> <span class="token punctuation">(</span>TextureImporter0<span class="token punctuation">)</span>assetImporter<span class="token punctuation">;</span>
            texureImporter<span class="token punctuation">.</span>isReadable <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>assetPath<span class="token punctuation">.</span><span class="token function">StartsWith</span><span class="token punctuation">(</span><span class="token string">"Assets/UI"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                textureImporter<span class="token punctuation">.</span>mipmapEnabled <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
                textureImporter<span class="token punctuation">.</span>textureType <span class="token operator">=</span> TextureImporterType<span class="token punctuation">.</span>Sprite<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>assetPath<span class="token punctuation">.</span><span class="token function">StartWith</span><span class="token punctuation">(</span><span class="token string">"Assets/Units"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                textureImporter<span class="token punctuation">.</span>textureFormat <span class="token operator">=</span> TextureImporterFormat<span class="token punctuation">.</span>AutomaticCompressed<span class="token punctuation">;</span>

            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>assetPath<span class="token punctuation">.</span><span class="token function">StartsWith</span><span class="token punctuation">(</span><span class="token string">"Assets/FX/Textures"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>textureImporter<span class="token punctuation">.</span>textureFormat <span class="token operator">==</span> TextureImporterFormat<span class="token punctuation">.</span>AutomaticTruecolor
                <span class="token operator">||</span> textureImporter<span class="token punctuation">.</span>textureFormat <span class="token operator">=</span> TextureImporterFormat<span class="token punctuation">.</span>Automatic16bit
                <span class="token operator">||</span> textureImporter<span class="token punctuation">.</span>textureFormat <span class="token operator">=</span> TextureImporterFormat<span class="token punctuation">.</span>ARGB16
                <span class="token operator">||</span> textureImporter<span class="token punctuation">.</span>textureFormat <span class="token operator">=</span> TextureImporterFormat<span class="token punctuation">.</span>RGB24
                <span class="token operator">||</span> textureImporter<span class="token punctuation">.</span>textureFormat <span class="token operator">=</span> TextureImporterFormat<span class="token punctuation">.</span>RGBA32
                <span class="token operator">||</span> textureImporter<span class="token punctuation">.</span>textureFormat <span class="token operator">=</span> TextureImporterFormat<span class="token punctuation">.</span>ARGB32
                <span class="token operator">||</span> textureImporter<span class="token punctuation">.</span>textureFormat <span class="token operator">=</span> TextureImporterFormat<span class="token punctuation">.</span>RGB16
                <span class="token operator">||</span> textureImporter<span class="token punctuation">.</span>textureFormat <span class="token operator">=</span> TextureImporterFormat<span class="token punctuation">.</span>RGBA16<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    textureImporter<span class="token punctuation">.</span>textureFormat <span class="token operator">=</span> TextureImporterFormat<span class="token punctuation">.</span>AutomaticCompressed<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>只有这个脚本在项目中（例如Editor文件夹中），这样导入的时候，就会自动执行，不用手动改了。</p>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>在 Unity 中， 前置堆内存分配，尽量降低碎片化；查验内存泄露；资源预处理；字符串拼接、配置表优化、对象池等等</p>
<p>内存的开销无外乎以下三大部分：<br>1.资源内存占用；2.引擎模块自身内存占用；3.托管堆内存占用。</p>
<p>对于目前绝大多数基于 Unity 引擎开发的项目而言，其托管堆内存是由Mono 分配和管理的。“托管” 的本意是 Mono 可以自动地改变堆的大小来适应你所需要的内存，并且适时地调用垃圾回收（Garbage Collection）操作来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。但是这并不意味着研发团队可以在代码中肆无忌惮地开辟托管堆内存，因为目前 Unity 所使用的 Mono 版本存在一个很严重的问题，即：Mono 的堆内存一旦分配，就不会返还给系统。这意味着 Mono 的堆内存是只升不降的。</p>
<p>同时我们要对自身 Log 的输出进行严格的控制。</p>
<h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p>在 Unity 中，采用 静态批处理、动态批处理、遮挡剔除、远近剔除、AOI、合理划分图集、动态图集、美术模型顶点控制、特效面数控制、GPU Instanceing、UGUI 使用的注意事项等等，来控制DrawCall; 业务代码执行效率优化等等。</p>
<p>目前的 Unity 移动游戏而言，CPU 方面的性能开销主要可归结为两大类：引擎模块性能开销和自身代码性能开销。其中，引擎模块中又可细致划分为渲染模块、动画模块、物理模块、UI 模块、粒子系统、加载模块和 GC 调用等等。</p>
<h3 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h3><p>OverDraw是指在渲染过程中重复绘制相同像素的现象。它会导致 GPU 不必要地进行多余的工作，消耗额外的性能资源，降低游戏的帧率和性能表现。</p>
<p>GPU 与 CPU 不同，所以侧重点自然也不一样。GPU 的瓶颈主要存在在如下的方面：<br>（1） 填充率，可以简单的理解为图形处理单元每秒渲染的像素数量。<br>（2） 像素的复杂度，比如动态阴影，光照，复杂的 shader 等等<br>（3） 几何体的复杂度（顶点数量）<br>（4） 当然还有 GPU 的显存带宽<br>那么针对以上 4 点，其实仔细分析我们就可以发现，影响的 GPU 性能的无非就是 2 大方面，一方面是顶点数量过多，像素计算过于复杂。另一方面就是GPU 的显存带宽。那么针锋相对的两方面举措也就十分明显了。<br>（1） 减少顶点数量，简化计算复杂度。<br>（2） 压缩图片，以适应显存带宽。</p>
<h4 id="MipMap-1"><a href="#MipMap-1" class="headerlink" title="MipMap"></a>MipMap</h4><p>Mipmap 中每一个层级的小图都是主图的一个特定比例的缩小细节的复制品。因为存了主图和它的那些缩小的复制品，所以内存占用会比之前大。但是因为可以根据实际情况，选择适合的小图来渲染。所以，虽然会消耗一些内存，但是优化了显存带宽，为了图片渲染的质量（比压缩要好），这种方式也是推荐的。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86426969">https://zhuanlan.zhihu.com/p/86426969</a></p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。<br>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<p>进行三次握手：</p>
<p>第一次握手（SYN）：客户端向服务器发送一个同步（SYN=1）报文，表示客户端请求建立连接。该报文中包含客户端的初始序列号ISN=x，用于后续数据传输的顺序标识。客户端处于 SYN_SEND 状态。</p>
<p>第二次握手（SYN + ACK）：服务器接收到客户端的请求后，会回复一个同步(SYN=1)-确认（SYN-ACK）报文。该报文中包含服务器的初始序列号(seq=y)和确认号（ACK=ISN+1），确认客户端的请求，并为后续数据传输做好准备。此时服务器处于 SYN_REVD 的状态。</p>
<p>第三次握手（ACK）：客户端收到服务器的回复后，会发送一个确认（ACK=y+1）报文，表示接收到服务器的确认。服务器收到客户端的确认后，建立连接，双方可以开始进行数据传输。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
<p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p>
<p>在socket编程中，客户端执行connect()时，将触发三次握手。</p>
<h4 id="为什么需要三次握手，两次不行吗"><a href="#为什么需要三次握手，两次不行吗" class="headerlink" title="为什么需要三次握手，两次不行吗"></a>为什么需要三次握手，两次不行吗</h4><p>第一次握手：保证客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：保证服务端的发送能力、客户端的接收能力是正常的。但是服务端不知道客户端的接收能力是否正常。<br>如果只有两次握手，将会出现下面情况：<br>客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。<br>因此意义如下：</p>
<ol>
<li>防止已失效的连接请求被误认为是新的连接：如果只有两次握手，客户端发送连接请求后，可能由于网络延迟或其他原因导致该请求长时间滞留在网络中，然后在一段时间后到达服务器。此时，服务器可能已经清除了之前的连接状态，无法正确识别该连接请求的有效性。通过增加第三次握手，客户端在收到服务器的确认后，可以确保之前的请求已经成功到达服务器，并避免了这种混淆。</li>
<li>防止服务器资源浪费：在两次握手的情况下，客户端发送的连接请求可能因为某种原因未能到达服务器，但服务器仍然为该连接分配了相应的资源。如果服务器长时间等待客户端的确认，这些资源将被浪费。通过增加第三次握手，服务器在收到客户端的确认后，可以确信客户端已经成功接收到了服务器的连接请求，避免了资源的浪费。</li>
<li>确保双方都愿意建立连接：三次握手中的第三次握手是客户端向服务器发送确认报文，表示客户端愿意正式建立连接。这样可以确保双方都同意建立连接，避免了无意义的连接建立。</li>
</ol>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。<br>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ol>
<li>客户端发送一个FIN报文（FIN=1,seq=u），用于关闭它的发送能力，进入FIN_WAIT_1状态。</li>
<li>服务器收到FIN报文后，发送一个ACK报文(ack=u+1,seq=v)作为应答，确认收到FIN，并进入CLOSE_WAIT状态。</li>
<li>服务器发送完剩下的数据，然后发送一个FIN报文（FIN=1,ack=u+1,seq=w），用于关闭它的发送能力，进入LAST_ACK状态。</li>
<li>客户端收到FIN报文后，发送一个ACK报文（ack=w+1）作为应答，进入TIME_WAIT状态。这个状态会持续2MSL（Maximum Segment Lifetime，最大报文生存时间）时间，等待可能出现的延迟报文。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ol>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<h4 id="为什么挥手需要四次"><a href="#为什么挥手需要四次" class="headerlink" title="为什么挥手需要四次"></a>为什么挥手需要四次</h4><p>当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
<h4 id="TCP为什么稳定"><a href="#TCP为什么稳定" class="headerlink" title="TCP为什么稳定"></a>TCP为什么稳定</h4><p>它提供了 乱序重排、应答确认、报文重传和流量控制 四种机制。<strong>乱序重排</strong>、<strong>应答确认</strong>都跟序号有关。由于网络或“多线程”等因素，接收方收到的数据段很可能是乱序的，不过，因为每个 TCP 封装都有序号，接收方重组起来非常容易。<br>TCP 的报文重传有两种独立的办法。 一种是<strong>超时重传</strong>，发送方收不到确认的时候用。我们都知道网速 并不是稳定的，传输时的每个报文的延时也不一样。TCP 会根据报文 的往返时间（RTT）自动调整超时重传时间（RTO）。发送方每发一 个报文段都会开始计时，如果时间超过 RTO 还没收到这个报文段的确 认，就重传该报文段。另一种方法是<strong>快速重传</strong>，发送的数据在路上丢失的时候用。接收方收到序号 1后，回复确认号 2，希望下次收到序号 2 的报文 段，但却乱序收到比序号 2 大的 3、4、5 报文段，于是连续发出确认 号为 2 的报文段。如果发送方连续三次收到重复的确认号，立即重发 该报文段，而不管是否超时。<br>window 还有一个很重要的作用，那就是 <strong>流量控制</strong>。 首先要明白一点，应用程序不论发送还是接收数据，都会先把数据放入缓冲区，再从缓冲区中发出或读取数据。 这个缓冲区大小，反映了应用程序一次能处理数据的能力。如果接收方应用程序处理速度比发送方的发送速度慢，就会造成接收方缓冲区“溢出”。实际上，发送方发送速度和接收方处理速度很难一致。 这就需要 window 来调整了。 TCP 在三次握手建立连接时，会协商双方缓冲区 window 大小。如果因 为接收方处理速度较慢，接收方会通过 window 告知发送方，实现动态调整，避免“溢出”。发送方会根据接收方确认报文中的 window 值来调整每次发出多少报文，这叫“滑动窗口”。</p>
<h4 id="TCP-IP五层及其作用"><a href="#TCP-IP五层及其作用" class="headerlink" title="TCP/IP五层及其作用"></a>TCP/IP五层及其作用</h4><p>计算机网络模型有七层：物理层，数据链路层，网络层，传输层，回话层，表示层，应用层。但这里简化为五层。<br>（1）物理层：负责光电信号传递方式。集线器工作在物理层。以太网协议。<br>（2）数据链路层：负责设备之间的数据帧的传输和识别。交换机工作在数据链路层。例如网卡设备的驱动，帧同步，冲突检测，数据差错校验等工作。<br>（3）网络层：负责地址管理和路由选择。路由器工作在网络层。<br>（4）传输层：负责两台主机之间的数据传输。<br>（5）应用层：负责应用程序之间的沟通。网络编程主要针对的就是应用层。</p>
<h4 id="为什么要有-TIME-WAIT-这个状态"><a href="#为什么要有-TIME-WAIT-这个状态" class="headerlink" title="为什么要有 TIME_WAIT 这个状态"></a>为什么要有 TIME_WAIT 这个状态</h4><ol>
<li>可靠终止 TCP 连接。如果最后一个 ACK 报文因为网络原因被丢弃，此时 server 因为没有收到 ACK 而超时重传 FIN 报文，处于 TIME_WAIT状态的 client 可以继续对 FIN 报文做回复，向 server 发送 ACK 报文。</li>
<li>保证让迟来的 TCP 报文段有足够的时间被识别和丢弃。连接结束了， 网络中的延迟报文也应该被丢弃掉，以免影响立刻建立的新连接。</li>
</ol>
<h4 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h4><p>TCP的流量控制是通过滑动窗口机制实现的，主要目的是确保发送方和接收方之间的数据传输速率匹配，防止发送方发送速度过快导致接收方无法及时处理或数据丢失。<br>具体来说，TCP的流量控制包括以下要点：</p>
<ol>
<li><p>滑动窗口大小：每个TCP连接都有一个滑动窗口，表示接收方当前可接收的字节范围。发送方根据接收方的窗口大小来确定发送数据的数量。</p>
</li>
<li><p>接收方通告窗口大小：接收方通过TCP报文段中的窗口字段通告发送方自己的窗口大小。发送方根据接收方通告的窗口大小来调整发送数据的数量。</p>
</li>
<li><p>滑动窗口的滑动：随着接收方处理已接收数据，窗口向前滑动，为新的数据腾出空间。</p>
</li>
<li><p>停止-等待流量控制：当发送方发送的数据超过接收方的窗口大小时，接收方会将窗口设置为0，停止接收数据，发送方必须等待接收方通告新的窗口大小后才能继续发送数据。</p>
</li>
<li><p>慢启动和拥塞避免：TCP的拥塞控制机制与流量控制密切相关。拥塞控制通过动态调整拥塞窗口大小来控制发送速率，避免网络拥塞。慢启动阶段发送方逐渐增加拥塞窗口的大小，拥塞避免阶段则以一种更渐进的方式增加窗口大小。</p>
</li>
</ol>
<p>总的来说，TCP的流量控制机制通过接收方通告窗口大小，发送方根据窗口大小调整发送数据的数量，确保发送速率与接收方的处理能力相匹配。这样可以避免数据的丢失和网络拥塞，保证可靠的数据传输。</p>
<h4 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h4><p>TCP的拥塞控制是一种机制，用于避免过多的数据流量拥塞网络，导致网络性能下降或数据丢失。它是为了保持网络的稳定性和公平性而设计的。<br>TCP的拥塞控制主要包括以下几个方面：</p>
<ol>
<li><p>慢启动（Slow Start）：在连接刚建立时，发送方先以较小的拥塞窗口开始发送数据，然后每经过一个往返时间（RTT），窗口大小就会加倍，以此逐渐增加发送速率。</p>
</li>
<li><p>拥塞避免（Congestion Avoidance）：一旦拥塞窗口达到一个阈值（拥塞窗口大小的一半），发送方将以一种线性增加的方式增加拥塞窗口的大小，以更稳定的速率发送数据。</p>
</li>
<li><p>快速重传（Fast Retransmit）：当接收方发现某个报文段丢失时，它会立即发送重复确认（duplicate ACK）给发送方。当发送方连续收到多个重复的ACK时，它会认为有一个报文段丢失，而不是等待超时后再进行重传，从而快速恢复丢失的数据。</p>
</li>
<li><p>快速恢复（Fast Recovery）：在快速重传的基础上，发送方将拥塞窗口减半，并进入快速恢复状态。在快速恢复状态下，发送方继续以较小的速率发送数据，直到再次达到拥塞窗口的阈值。</p>
</li>
</ol>
<p>通过这些机制，TCP可以根据网络的拥塞程度来动态调整发送速率，以避免网络拥塞的发生并保持网络的稳定性。拥塞控制使得TCP在不同网络条件下都能提供可靠的数据传输，并且在网络出现拥塞时能够自适应地减少发送速率，从而减轻网络的负载。</p>
<h4 id="断线重连逻辑"><a href="#断线重连逻辑" class="headerlink" title="断线重连逻辑"></a>断线重连逻辑</h4><p>当检测到客户端断线时，断开当前客户端 Socket；重新根据 IP 和端口号重建新的 Socket。当连接上服务器网关后，携带 token，向服务器发送断线重连协议。</p>
<h3 id="TCP-UDP-的区别，用在什么场景"><a href="#TCP-UDP-的区别，用在什么场景" class="headerlink" title="TCP/UDP 的区别，用在什么场景"></a>TCP/UDP 的区别，用在什么场景</h3><ol>
<li>基于连接 vs 无连接<br>a. TCP 是面向连接的协议<br>b. UDP 是无连接的协议。UDP 更加适合消息的多播发布，从单个点向多个点传输消息</li>
<li>可靠性<br>a. TCP 提供交付保证，传输过程中丢失，将会重发<br>b. UDP 是不可靠的，不提供任何交付保证（网游和视频丢包情况）</li>
<li>有序性<br>a. TCP 保证了消息的有序性，即使到达客户端顺序不同，TCP 也会排序<br>b. UDP 不提供有序性保证</li>
<li>数据边界<br>a. TCP 不保存数据边界。虽然 TCP 也将在收集所有字节之后生成一个完整的消息，但是这些信息在传给传输给接受端之前将储存在 TCP 缓冲区，以确保更好的使用网络带宽。<br>b. UDP 保证。在 UDP 中，数据包单独发送的，只有当他们到达时，才会再次集成。包有明确的界限来哪些包已经收到，这意味着在消息发送后，在接收器接口将会有一个读操作，来生成一个完整的消息。</li>
<li>速度<br>a. TCP 速度慢<br>b. UDP 速度快。应用在在线视频媒体，电视广播和多人在线游戏</li>
<li>发送消耗<br>a. TCP 是重量级<br>b. UDP 是轻量级。因为 UDP 传输的信息中不承担任何间接创造连接，保证交货或秩序的的信息。这也反应在包头大小。</li>
<li>报头大小<br>a. TCP 头大。一个 TCP 数据包报头的大小是 20 字节。TCP 报头中包含序列号，ACK 号，数据偏移量，保留，控制位，窗口，紧急指针，可选项，填充项，校验位，源端口和目的端口。<br>b. UDP 头小。UDP 数据报报头是 8 个字节。而 UDP 报头只包含长度，源端口号，目的端口，和校验码。</li>
<li>流量控制<br>a. TCP 有流量控制。主要目的是确保发送方和接收方之间的数据传输速率匹配，防止发送方发送速度过快导致接收方无法及时处理或数据丢失。<br>b. UDP 不能进行流量控制</li>
</ol>
<p>TCP用于状态同步，例如 MMORPG，使用 TCP 状态同步<br>UDP用于帧同步，例如MOBA游戏，使用 UDP 帧同步</p>
<h3 id="数据链路层和传输层有什么区别"><a href="#数据链路层和传输层有什么区别" class="headerlink" title="数据链路层和传输层有什么区别"></a>数据链路层和传输层有什么区别</h3><p>数据链路层和传输层的主要区别是：他们的功能和作用不一样。 数据链路层负责建立和管理节点间的链路。主要功能是通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。传输层是通信子网和资源子网的接口和桥梁。主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。 另外传输层的环境比数据链路层的环境要复杂得多。这是由于传输层的环境是两个主机以整个子网为通信信道进行通信，并且传输的数据是<strong>报文</strong>。而数据链路层的环境是两个分组交换结点直接通过一条物理信道进行通信。传输的数据是<strong>信息帧</strong>。</p>
<h3 id="http原理"><a href="#http原理" class="headerlink" title="http原理"></a>http原理</h3><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24913080">https://zhuanlan.zhihu.com/p/24913080</a><br>HTTP，全称为 HyperText Transfer Protocol，即为超文本传输协议。是互联网应用最为广泛的一种网络协议，所有的 www 文件都必须遵守这个标准。HTTP 一般构建于 TCP/IP 协议之上，默认端口号是 80<br>HTTP 定义了在与服务器交互的不同方式，最常用的方法有 4 种，分别是 GET，POST，PUT， DELETE。URL 全称为资源描述符，可以这么认为：一个 URL 地址，对应着一个网络上的资源，而 HTTP 中的 GET，POST，PUT，DELETE 就对应着对这个资源的查询，修改，增添，删除4个操作。<br>特点：</p>
<ol>
<li>无连接性：每个HTTP请求都是独立的，服务器不会保留客户端的状态信息，每次请求都需要重新建立连接。</li>
<li>无状态性：HTTP协议本身不会对请求和响应之间的状态进行保持，每个请求都是独立的，服务器不会记住之前的请求信息。</li>
<li>基于请求-响应模型：客户端发送一个HTTP请求到服务器，服务器接收并处理请求后，返回一个HTTP响应给客户端。</li>
<li>简单可读的文本协议：HTTP协议使用文本格式进行数据交换，易于理解和调试。</li>
<li>支持多媒体内容：HTTP协议可以传输各种类型的数据，包括文本、图像、音频、视频等。</li>
</ol>
<h3 id="https-为什么安全？https-传输过程是怎样的？为什么需要证书？使用https-会被抓包么"><a href="#https-为什么安全？https-传输过程是怎样的？为什么需要证书？使用https-会被抓包么" class="headerlink" title="https 为什么安全？https 传输过程是怎样的？为什么需要证书？使用https 会被抓包么"></a>https 为什么安全？https 传输过程是怎样的？为什么需要证书？使用https 会被抓包么</h3><p>为什么安全？<br>因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性。<br>传输过程<br>客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。</p>
<p>为什么需要证书？<br>防止”中间人“攻击，同时可以为网站提供身份证明。<br>会被抓包么？<br>会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。</p>
<h3 id="端口号划分"><a href="#端口号划分" class="headerlink" title="端口号划分"></a>端口号划分</h3><p>0-1023：知名端口号，HTTP,FTP,SSH 这些广为使用的应用层协议，他们的端口号都是固定的：<br>HTTP:80<br>HTTPS：443<br>SSH：22<br>FTP:21<br>Telent：23</p>
<p>1024-65535：操作系统动态分配的端口号，客户端程序的端口号，就是由操作系统从这个范围分配的。</p>
<h3 id="如何判断当前机器是大端还是小端"><a href="#如何判断当前机器是大端还是小端" class="headerlink" title="如何判断当前机器是大端还是小端"></a>如何判断当前机器是大端还是小端</h3><p>大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中。<br>小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> BitConverter<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"小端"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span><span class="token punctuation">{</span>
  Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"大端"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="详细讲讲在服务器计算和在客户端计算的优缺点"><a href="#详细讲讲在服务器计算和在客户端计算的优缺点" class="headerlink" title="详细讲讲在服务器计算和在客户端计算的优缺点"></a>详细讲讲在服务器计算和在客户端计算的优缺点</h3><p><strong>服务器计算</strong></p>
<ol>
<li>可靠性和安全性：服务端拥有更大的计算资源和更强的安全控制能力，可以进行复杂的计算和数据处理，确保数据的准确性和安全性。</li>
<li>数据集中管理：服务端负责整个系统的核心业务逻辑和数据管理，可以实现数据的集中存储和管理，提高数据一致性和可靠性。</li>
<li>减轻客户端负担：服务端进行计算和处理，可以减轻客户端的计算负担和网络传输压力，提升客户端的响应速度和用户体验。</li>
</ol>
<p>缺点：</p>
<ol>
<li>延迟：客户端需要等待服务端的计算结果返回，可能会增加请求的响应时间和延迟。</li>
<li>服务器压力：服务端需要处理大量的客户端请求，需要具备足够的计算资源和扩展能力来应对高并发情况。</li>
</ol>
<p><strong>客户端计算</strong><br>优势释放服务器端压力，将计算量移到了客户端。并提高了用户的响应速度和实时性。<br>劣势是数据不可靠，可能会导致外挂。多个客户端进行独立计算可能导致数据的一致性问题，需要额外的同步和数据校验机制来保证数据的一致性。</p>
<h3 id="网络同步中可以进行哪些优化"><a href="#网络同步中可以进行哪些优化" class="headerlink" title="网络同步中可以进行哪些优化"></a>网络同步中可以进行哪些优化</h3><p>表现优化、延迟对抗、丢包对抗、带宽优化以及帧率优化</p>
<h4 id="表现优化"><a href="#表现优化" class="headerlink" title="表现优化"></a>表现优化</h4><p>（1） 差值优化<br>内插值的目的是解决客户端离散信息更新导致的突变问题，外插值的目的是解决网络延迟过大或者抖动导致间歇性收不到数据而卡顿的问题，两种方案并不冲突，可以同时采用。在具体应用时，我们可以使逻辑帧与渲染帧分离，这样在客户端没有收到新数据的时候还可以继续更新渲染位置（只对渲染的模型位置信息进行插值）。<br>（2） 客户端预先执行+回滚<br>预测的目的是让玩家能在本地操作后立刻收到反馈，提升游戏体验，回滚是为了保证服务器的权威性。客户端预测包括位置预测以及行为预测两种，位置预测需要高频率的执行，因为移动在每帧都可能发生，而其他行为预测则相对低频一些，包括开枪、扔手雷、释放技能等。另外，对于延迟不太敏感的游戏（比如 MMO），可以放宽校验条件（超过一定误差再纠正），这样即使降低服务器帧率客户端也不会有什么感觉。</p>
<h4 id="延迟对抗"><a href="#延迟对抗" class="headerlink" title="延迟对抗"></a>延迟对抗</h4><p>（1） 延迟补偿<br>服务器（注意是服务器而不是客户端）记录一段时间内所有玩家的位置历史，在发生伤害计算时根据延迟对所有玩家角色进行位置的回滚与处理，可以尽量还原当时的场景。<br>（2） 命令缓冲区<br>把远端的数据缓存在一个 buffer 里面，然后按照固定频率从 buffer 里面取，可以解决客户端卡顿以及网络抖动问题。不过缓冲区与延迟是有冲突的，缓冲区越大，证明我们缓存的远端数据就越多，延迟就越大。<br>（3）从具体实现的技巧上对抗延迟<br>客户端操作加一个前摇时间，释放技能等行为前有一个播放动画表现的时间来抵消掉同步 RTT 的延迟。比如角色释放无敌技能在进入无敌状态前做一个过度动画，客户端播放动画后进入无敌，但是服务器可以在收到指令后直接进入无敌状态从而抵消延迟。在游戏 Halo 中，有很多类似的例子，如在客户端玩家扔手雷的时候，我们可以在本地立刻播放扔手雷的动画并发送请求到服务器，然后服务器收到后不需要播放动画立刻生成手雷并同步，这样客户端真正扔出手雷的表现就是 0 延迟的</p>
<h4 id="丢包对抗"><a href="#丢包对抗" class="headerlink" title="丢包对抗"></a>丢包对抗</h4><ol>
<li>使用 TCP 而不是 UDP。由于 TCP 不会丢包，对于延迟不敏感的游戏还是优先采取TCP 来对抗丢包</li>
<li>冗余 UDP 数据包<br>一次性发送多个帧的数据来对抗丢包。UDP 同步数据时经常容易丢包，我们虽然可以使用上层实现 UDP 的可靠性，但是像帧同步这种同步数据量比较小的游戏可以采用冗余 UDP 的方案，即后续的 UDP 包会冗余一定量的前面已发送的 UDP 包，这样即使丢失了部分包我们也能保证拿到完整的远端数据。</li>
</ol>
<h4 id="带宽优化"><a href="#带宽优化" class="headerlink" title="带宽优化"></a>带宽优化</h4><p>带宽优化的目的是减小客户端以及服务器的同步压力，避免大量数据同时传输造成处理不过来，排队甚至是丢失。带宽优化是非常灵活且多变的，我们需要根据游戏的玩法来调整我们的优化行为。</p>
<ol>
<li>同步对象裁剪。核心目的是根据相关性剔除那些不需要同步的对象（这里都是指在同一个服务器内），比如一个玩家距离我很远，我们的行为彼此不会影响，所以就不需要互相同步对方的数据。裁剪方式有非常多，常见的 SOI（Spheres of Influence），静态区域（把场景划分为 N个小区域，不在一个区域不同步），视锥裁剪（更多用于渲染），八叉树裁剪等。相关性还可能会涉及到声音等其他因素，需要根据自己项目来决定。这里着重提一点 AOI ( Area Of Interest) ，即根据玩家的位置维护一个动态的视野列表，视野外的对象会被完全忽略（能大幅的减少同步对象的遍历与比较）。其基本思想也是判断相关性，实现方式有很多，<br>其中基于格子的空间划分算法是网络游戏中常见的实现方案。在虚幻引擎中，大世界同步框架<br>ReplicationGraph的核心思想也是如此。不过要注意的是，对于 MMO 这种可能有大量角色同时进行连续移动的游戏，视野列表频繁的增删查操作也可能对服务造成一定的压力。</li>
<li>分区，分房间<br>对于大型 MMO 来说，这是常见的手段，将不同的玩家分散到不同的场景内（不同的服务器），这样减小服务器处理数据的压力，减小延迟。对于大世界游戏而言，不同服务器可能接管同一个地图不同区域的服务，其中的跨服数据同步比较复杂。</li>
<li>数据压缩与裁剪<br>坐标与旋转是我们常见的同步内容，但是很多数据其实是不需要同步的。比如对于大部分 3D 游<br>戏角色的 Pitch 以及 Roll 是不会改变的，我们只要同步 Yaw 值即可。对于非第一人称游戏，我们可以接着把四个字节 float 类型的 Yaw 压缩到两个字节的 uint16 里面，玩家根本不会有什么体验上的差异。类似的方法可以应用到各种同步数据里面。此外，在状态同步里面，我们可以采用增量发送来减少数据量，即第一次发送完整的数据信息后只发送哪些发生过变化的数据，这可以大大减少网络同步的流量。</li>
<li>减少遍历以及更细力度的优化在 Halo 以及虚幻引擎里面都会对同步对象做优先级划分，发送频率调整等。在状态同步中，我们还需要合适的手段来快速定位发生变化的数据，如属性置脏、利用反射减少非同步属性的遍历等。进一步的，我们还可以根据客户端的类型以及信息作出更细致的同步信息过滤以及设置优先级，比如对同步属性进行优先级划分等（目前还没有见到过粒度如此细致的，但理论上是可行的）</li>
</ol>
<h4 id="帧率优化"><a href="#帧率优化" class="headerlink" title="帧率优化"></a>帧率优化</h4><p>帧率优化是一个重要且复杂的难题，涉及到方方面面的技术细节，这里主要针对网络同步相关内容做一些分析。相比单机游戏，网游需要同时考虑客户端与服务器的帧率，这并不是单纯地提升帧率的问题，如何优化与平衡是一个很微妙的过程。</p>
<ol>
<li>提升帧率<br>这个不用多说，帧率低就意味着卡顿，玩家的体验就会很差。不同游戏的性能瓶颈都可能不一样，包括内存问题（GC、频繁的申请与释放）、IO（资源加载、频繁的读写文件，网络包发送频率过大，数据库读取频繁）、逻辑问题（大量的遍历循环，无意义的 Tick，频繁的创建删除对<br>象，过多的加锁，高频率的 Log）、AI（寻路耗时）、物理问题（复杂模拟，碰撞次数过多）、语言特性（脚本语言比较费时）等，客户端相比服务器还有各种复杂的渲染问题（Drawcall 太多，半透明，动态阴影等）。这些问题需要长期的测试与调试，每个问题涉及到的具体细节可能都有所不同，需要对症下药才行。</li>
<li>保持帧率稳定与匹配<br>假如你的客户端与服务器帧率已经优化到极致，你也不能任其自由变化。首先，要尽量保持服务器的帧率稳定（减少甚至是消除玩家比赛时的所有潜在的卡顿问题），考虑一款对延迟比较敏感的射击游戏，如果你的客户端在开枪时遇到了服务器卡顿，那么就可能造成校验失败，导致客户端看到的行为与服务器行为不一致。其次，还要保持客户端与服务器的帧率匹配。对于延迟不敏感的游戏，考虑到玩家的体验以及服务器的压力，客户端的帧率可以高于服务器多倍，但是这个比例是需要通过实际的测试来调整。而对于延迟敏感的游戏，我们一般需要尽量让服务器的帧率接近客户端，这样服务器才能更及时的相应，减少延迟带来的误差。此外，我们也不能让客户端的帧率无限提高，对于某些同步算法，客户端与服务器过高的帧率差异可能造成不断的拉回卡顿。所以，很多游戏会采取锁帧的方式来保证游戏的稳定性。</li>
<li>计算压力分担<br>对于 MMO 这种服务器压力比较大的游戏，我们通常会考虑把一部分计算资源转交给客户端去计算（甚至是计算后再返还给服务器），比如物理运算、自动寻路、AI 逻辑计算等。其实将这种方式使用到极致的例子就是帧同步，服务器只做一些简单的校验即可。</li>
</ol>
<h3 id="IO-多路复用，select-vs-poll，epoll-vs-poll-amp-select"><a href="#IO-多路复用，select-vs-poll，epoll-vs-poll-amp-select" class="headerlink" title="IO 多路复用，select vs poll，epoll vs poll&amp;select"></a>IO 多路复用，select vs poll，epoll vs poll&amp;select</h3><p>IO多路复用是一种网络编程技术，用于在单个线程中管理多个网络连接。它通过使用操作系统提供的特定API（如select、poll、epoll等）来监听多个文件描述符（通常是套接字），以实现同时监测多个I/O事件的能力。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/v123411739/article/details/124699602">https://blog.csdn.net/v123411739/article/details/124699602</a><br>Socket：对网络中不同逐级上的应用程序之间进行双向通信的端点的抽象，相当于客户端服务器通信的入口。<br>FD(file desriptor)linux 中的一切资源都可以通过文件的方式访问和管理。而 FD 就类似文件的索引（符号、指针），指向某个资源，内核（kernel）利用 FD 来访问和管理资源。我们调用内核函数创建 socket 后，内核返回给我们的是 socket 对应的文件描述符（fd），所以我们对 socket 的操作基本都是通过 fd 来进行。</p>
<p>核心交互流程如下：</p>
<p>1）服务器端通过 socket、bind、listen 对 socket 进行初始化，最后阻塞在 accept 等待客户端请求到来。</p>
<p>2）客户端通过 socket 进行初始化，然后使用 connect 向服务端发起连接请求。此时客户端会和服务端进行 TCP 三次握手，三次握手完成后，客户端和服务端建立连接完毕，开始进入数据传输过程。</p>
<p>3）客户端发起 write 系统调用写入数据，数据从用户空间拷贝到内核空间 socket 缓冲区，最后内核将数据通过网络发送到服务器。</p>
<p>4）数据经过网络传输到达服务器网卡，接着内核将数据拷贝到对应的 socket 接收队列，最后将数据从内核空间拷贝到用户空间。</p>
<p>5）客户端和服务器完成交互后，调用 close 函数来断开连接。</p>
<p><strong>同步阻塞IO</strong>：当应用程序发起 read 系统调用时，在内核数据没有准备好之前，应用程序会一直处于阻塞等待状态，直到内核把数据准备好了返回给应用程序<br> 大致流程如下：<br>1）服务端进行初始化：新建 socket、绑定地址、转为服务端 socket<br>2）服务端调用 accept，进入阻塞状态，等待客户端连接<br>3）客户端新建 socket，向服务端发起连接<br>4）服务端和客户端通过 TCP 三次握手建立连接<br>5）服务端继续执行 read 函数，进入阻塞状态，等待客户端发送数据<br>6）客户端向服务端发送数据<br>7）服务端读取数据，执行逻辑处理</p>
<p>总结<br>单线程：某个 socket 阻塞，会影响到其他 socket 处理。<br>多线程：当客户端较多时，会造成资源浪费，全部 socket 中可能每个时刻只有几个就绪。同时，线程的调度、上下文切换乃至它们占用的内存，可能都会成为瓶颈。</p>
<p><strong>同步非阻塞IO</strong></p>
<p> 大致流程如下：<br>1）服务端调用 accept，数据未就绪，内核返回-1<br>2）服务端调用 accept，数据未就绪，内核返回-1<br>3）服务端调用 accept，数据未就绪，内核返回-1<br>4）客户端新建 socket，向服务端发起连接<br>4）服务端调用 accept，服务端和客户端通过 TCP 三次握手建立连接<br>5）服务端执行后续逻辑处理</p>
<p>提供了非阻塞调用的方式，从操作系统层面解决了阻塞问题。单个 socket 阻塞，不会影响到其他 socket 但是需要不断的遍历进行系统调用，有一定开销。</p>
<p>select<br>核心流程<br>1）应用程序首先发起 select 系统调用，传入要监听的文件描述符集合<br>2）内核遍历应用程序传入的 fd 集合，如果遍历完一遍后发现没有就绪的 fd 则用户进程会进入阻塞状态，如果有就绪的 fd 则会对就绪的 fd 打标，然后返回<br>3）应用程序遍历 fd 集合，找到就绪的 fd，进行相应的事件处理</p>
<p>优点：不需要每个 FD 都进行一次系统调用，解决了频繁的用户态内核态切换问题<br>缺点：</p>
<ul>
<li>单进程监听的 FD 存在限制，默认1024</li>
<li>每次调用需要将 FD 从用户态拷贝到内核态</li>
<li>不知道具体是哪个文件描述符就绪，需要遍历全部文件描述符</li>
<li>入参的3个 fd_set 集合每次调用都需要重置</li>
</ul>
<p>poll<br>poll 函数基本同 select，只是对 select 进行了一些小优化，一个是优化了1024个文件描述符上限，另一个是新定义了 pollfd 数据结构，使用两个不同的变量来表示监听的事件和就绪的事件，这样就不需要像 select 那样每次重置 fd_set 了。</p>
<p>epoll<br>核心流程<br>1）应用程序调用 epoll_create，内核会分配一块内存空间，创建一个 epoll，最后将 epoll 的 fd 返回，我们后续可以通过这个 fd 来操作 epoll 对象<br>2）应用程序不断调用 epoll_ctl 将我们要监听的 fd 维护到 epoll，内核通过红黑树的结构来高效的维护我们传入的 fd 集合<br>3）应用程序调用 epoll_wait 来获取就绪事件，内核检查 epoll 的就绪列表，如果就绪列表为空则会进入阻塞，否则直接返回就绪的事件。<br>4）应用程序根据内核返回的就绪事件，进行相应的事件处理</p>
<p>epoll 直接将 fd 集合维护在内核中，通过<strong>红黑树</strong>来高效管理 fd 集合，同时维护一个<strong>就绪列表</strong>，当 fd 就绪后会添加到就绪列表中，当应用空间调用 epoll_wait 获取就绪事件时，内核直接判断就绪列表即可知道是否有事件就绪。</p>
<p>LT：Level-triggered，水平（条件）触发，默认。epoll_wait 检测到事件后，如果该事件没被处理完毕，后续每次 epoll_wait 调用都会返回该事件。<br>ET：Edge-triggered，边缘触发。epoll_wait 检测到事件后，只会在当次返回该事件，不管该事件是否被处理完毕。</p>
<p>优点<br>解决了 select 和 poll 的缺点，高效处理高并发下的大量连接，同时有非常优异的性能。</p>
<p>缺点</p>
<ul>
<li>跨平台性不够好，只支持 linux，macOS 等操作系统不支持</li>
<li>相较于 epoll，select 更轻量可移植性更强</li>
<li>在监听连接数和事件较少的场景下，select 可能更优</li>
</ul>
<h3 id="时间处理模式reactor和proreactor区别-待续"><a href="#时间处理模式reactor和proreactor区别-待续" class="headerlink" title="时间处理模式reactor和proreactor区别(待续)"></a>时间处理模式reactor和proreactor区别(待续)</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12U4y167sf">https://www.bilibili.com/video/BV12U4y167sf</a></p>
<p>Reactor和Proactor是两种常见的事件处理模式，用于处理异步事件和I/O操作。它们在编程领域中被广泛应用于实现高性能、可扩展的系统。下面是它们的区别：</p>
<p>Reactor（反应器）模式：<br>Reactor模式基于事件驱动，使用一个事件循环（Event Loop）来等待和分发事件。<br>在Reactor模式中，所有的I/O操作都是同步的，当有一个I/O请求到达时，事件循环会通知相应的处理程序进行处理。<br>Reactor模式适用于处理少量的并发连接，并且处理程序通常是单线程的。它的主要优势在于简单性和低延迟。</p>
<p>Proactor（主动器）模式：<br>Proactor模式也是基于事件驱动的，但与Reactor模式不同，Proactor模式下的I/O操作是异步的。<br>在Proactor模式中，I/O操作的发起和完成是分离的。当一个I/O请求被发起后，程序可以继续执行其他任务，当I/O操作完成后，系统会通知相应的处理程序进行处理。<br>Proactor模式适用于处理大量的并发连接，特别是在高负载和高并发的情况下。它的主要优势在于并发性和可扩展性。<br>总的来说，Reactor模式适用于处理少量的连接和低延迟的场景，而Proactor模式适用于处理大量的连接和高并发的场景。选择使用哪种模式需要根据具体的应用需求和性能要求来进行评估。</p>
<h3 id="帧同步为什么要自研物理引擎"><a href="#帧同步为什么要自研物理引擎" class="headerlink" title="帧同步为什么要自研物理引擎"></a>帧同步为什么要自研物理引擎</h3><p>物理引擎内部是由浮点数参与计算的，而浮点数在不同平台产生的结果也不一样，就导致了结果有所浮动，且不一致，所以会造成不同步。因此就衍生出了定点数。而帧同步为了保证各平台同步的情况下，则必须使用定点数物理库。</p>
<h3 id="帧同步如何反外挂"><a href="#帧同步如何反外挂" class="headerlink" title="帧同步如何反外挂"></a>帧同步如何反外挂</h3><p>多人竞技的帧同步比较容易反挂，王者也是通过客户端上传关键数据的hash 投票找出作弊玩家。如果要对单机，双人等人数较少的帧同步游戏反挂，可以结算之后服务器再加速跑一边录像做验证，例如刀塔传奇。</p>
<h3 id="帧同步如何做预表现"><a href="#帧同步如何做预表现" class="headerlink" title="帧同步如何做预表现"></a>帧同步如何做预表现</h3><p>预测就是将玩家的输入立即应用到本地状态，而无需等待服务端返回。但是由于延迟的存在，服务端的同步总是滞后的，所以你总是被拉回之前的位置，所以看到的抖动和拉扯。归根到底，是服务端同步过来的状态与本地预测的状态不一致，所以我们需要 “和解” 它们</p>
<p>如果使用的是状态同步，和解过程是：<br>（1） 收到服务端同步来的 权威状态<br>（2） 将本地状态立即设为此权威状态<br>（3） 在权威状态的基础上，应用当前所有 预测输入</p>
<p>如果使用的是帧同步，和解过程是：<br>（1） 收到服务端同步来的权威输入<br>（2） 将本地状态立即 回滚 至 上一次的权威状态<br>（3） 将权威输入应用到当前状态，得到此次的 权威状态<br>（4） 在权威状态的基础上，应用当前所有 预测输入<br>由此可见，状态同步和帧同步只是网络传输的内容不同，但它们是完全可以相互替代的 —— 最终目的都是为了同步权威状态。</p>
<h3 id="帧同步中，逻辑渲染如何分离"><a href="#帧同步中，逻辑渲染如何分离" class="headerlink" title="帧同步中，逻辑渲染如何分离"></a>帧同步中，逻辑渲染如何分离</h3><p>多人实时游戏，通常会划分为表现层和逻辑层。 表现层指游戏画面的显示和用户输入的获取； 逻辑层指渲染无关的、只关注状态变化和计算的玩法逻辑。</p>
<p>逻辑层本质上就是一个状态机。在实现逻辑层的过程中，有几个重要的点需要关注：<br>（1） 无输入，不变化：状态变更仅发生在输入时刻，没有输入时状态不会改变<br>（2） 状态计算应该没有任何外部依赖，例如 Data.now()、Math.random()等，所有这些都应该显式成为输入的一部分<br>（3） 结果的一致性：在相同的状态和输入下，得到的新状态应该是一致的</p>
<p>像随机数这类场景，可以通过伪随机数生成器实现，在相同的种子输入下，随机结果应该是一致的。</p>
<h3 id="帧同步中产生不同步的原因以及解决方案"><a href="#帧同步中产生不同步的原因以及解决方案" class="headerlink" title="帧同步中产生不同步的原因以及解决方案"></a>帧同步中产生不同步的原因以及解决方案</h3><p>首先我们要弄清楚帧同步中的不同步是指什么?帧同步的原理是客户端计算，服务器转发给所有客户端，客户端表现一致。这机制就导致了服务器是不知道具体的计算逻辑的，如果客户端在进行逻辑运算时，在某一帧的变量不一致，随着时间的推移，会将这个差异扩大化，形成雪球效应，最后各个客户端得到的结果不一致。总结就是各个客户端无法保证输入以及计算的一致性，就无法保证输出结果的唯一性，因而就产生了不同步的情况。<br>（1） 数值的随机性。格斗类游戏中的事件随机性是它的一大魅力所在。例如闪避机制，暴击伤害等。由于帧同步中的逻辑都在客户 端进行，每个客户端对这类事件进行计算，就没有唯一<br>性。举例 玩家 A 的暴击几率是 80%，假设在第 200 帧中，玩家A 进行了一次 平 A 攻击，客户端 A 计算得到这次攻击产生了暴132击伤害 300，而客 户端 B 计算得到的结果是暴击伤害 280。这就导致了伤害不一致，随着战斗的进行两边客户端的差距会越来越大，得到不同的战斗结果。而帧同步就需要解决这类事件，保证两边随机结果的一致性。解决方案是客户端做伪随机算法。战斗开始时，服务器给客户端下发一个随机种子，通过自定义随机算<br>法，保证每次的随机结果都是可控且一致的。</p>
<p>（2） 逻辑执行顺序不一致。我们项目中用到了很多第三方的插件（例如 PlayMaker、NGUI）,这些插件的 Update 是没法由帧同步去控制的，各个客户端可能执行某个计算片段的时间并不是在同一逻辑帧内导致出现不同步的情况。unity 的物理系统，动画系统也是如此。解决方案就是不使用第三方插件，使用成熟稳定的开源插件或者自己实现，保证每个 update 都是自主可控的。避免出现不可控导致的不同步的情况出现。</p>
<p>（3） 数学计算中的精度丢失。精度丢失的情况主要是出现在浮点运算中。不同的硬件环境下浮点数的运算结果可能是不一致的。可能在一帧中的差异性很小，但随着时间推移造成的雪球效应会导致客户端得到不同的结果。要保证在不同的硬件环境下，运算结果的一致性就需要使用定点数替代浮点数，根据需求定一个比值参数（我们项目采用的是万分比）进行定点数和浮点数的转换。这样就保证了不会出现计算中的精度丢失问题。</p>
<p>（4） 接收网络数据不一致。因为 UDP 的不可靠性以及复杂的网络环境，在出现网络波动的情况下，接收端接收到的消息是无序的，客户端在接收服务器发送的消息时，后发的消息可能会比先发的消息还要先接收到，如果这时候客户端不进行处理的话，就会出现客户端先处理后一条消息，再处理前一条消息的情况，这样就会造成客户端对于操作输入的顺序不一致，也是会造成最终的不同步的。解决方案就是对每一个发出的消息做一个自增的编号，根据编号的连续性确定消息的顺序，就算先收到后面的消息，也可以等待前面的消息收到之后进行顺序传入游戏逻辑中。</p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="三个矩阵的顺序"><a href="#三个矩阵的顺序" class="headerlink" title="三个矩阵的顺序"></a>三个矩阵的顺序</h3><p>旋转矩阵，平移矩阵，缩放矩阵，三个动作的先后顺序（出自腾讯、网易）<br>先平移、然后旋转、最后缩放。</p>
<h3 id="欧拉角的万向节死锁和四元数"><a href="#欧拉角的万向节死锁和四元数" class="headerlink" title="欧拉角的万向节死锁和四元数"></a>欧拉角的万向节死锁和四元数</h3><p>在三维空间中，欧拉角是一种常用的表示物体旋转的方法，它由三个旋转轴和对应的旋转角度组成。然而，欧拉角存在一个问题，即当旋转角度接近某些特定值时，会导致旋转轴发生奇异性，从而使得物体的旋转过程出现异常。例如y轴旋转90度会导致x的旋转和z轴重合导致失去一个轴的自由度。这是因为欧拉角的旋转是相对于初始姿态来说的，并且是先旋转x再旋转y再旋转z。<br>x,y,z的旋转顺序不可改变，否则会导致姿态不一致，如果在y或z调整完了以后调整x轴，你想象中x的旋转发生在最后，实际上x的旋转会被加到一开始x的旋转变量上，所以导致了实际情况和直觉不符。这导致了死锁的发生。这会导致动画插值过渡的问题。</p>
<p>四元数是解决万向节死锁的方法，用四个数代表物体的旋转。四元数（Quaternions）是一种表示三维空间旋转的数学工具。它可以通过四个实数（a, b, c, d）来表示，常见的表示形式为 q = a + bi + cj + dk。其中，a 是实部，(b, c, d) 是虚部，而 (i, j, k) 则是三个相互正交的单位虚数。</p>
<p>四元数表示旋转的基本思想是利用一个单位四元数来表示旋转轴和旋转角度的组合。具体步骤如下：</p>
<p>定义旋转轴：选择一个单位向量 (x, y, z) 作为旋转轴，表示物体绕该轴进行旋转。</p>
<p>定义旋转角度：选择一个角度 θ，表示旋转的大小。</p>
<p>构造单位四元数：根据旋转轴和旋转角度构造一个单位四元数。常用的方式是通过旋转轴 (x, y, z) 和旋转角度 θ，计算出四元数的虚部 (b, c, d)。</p>
<p>b = x * sin(θ/2)<br>c = y * sin(θ/2)<br>d = z * sin(θ/2)</p>
<p>实部 a 的值通常为 cos(θ/2)。</p>
<p>执行旋转：将要旋转的点（向量）表示为四元数的虚部（0, x’, y’, z’），其中 (x’, y’, z’) 是点的坐标。</p>
<p>进行旋转：通过四元数的乘法运算将旋转应用于要旋转的点。乘法操作为：</p>
<p>q’ = q * p * q^(-1)</p>
<p>其中 q 是旋转的四元数，p 是要旋转的点（四元数表示），q^(-1) 是 q 的逆四元数。</p>
<p>最后得到的四元数 q’ 的虚部（0, x’’, y’’, z’’）即为旋转后的点的坐标。</p>
<p>三维旋转就是四维旋转的一个特例，就像二维旋转是三维旋转的一个特例一样。说是特例其实不准确，准确的说是一个子集或者subgroup。为了进行三维旋转运算，汉密尔顿首先在四维空间里划出了一块三维空间。汉密尔顿定义了一种纯四元数（pure quaternion），其表达式为qw=(0,wx,wy,wz)。纯四元数第一项为零，它存在于四维空间的三维超平面上，与三维空间中的三维向量一一对应。然后，就有了我们常见的q∗qw∗q−1这种左乘单位四元数，右乘其共轭的表达式。。简单的说，当对一个三维向量进行三维旋转后，我们希望得到的是一个三维向量。那么这个左乘单位四元数，右乘其共轭的运算保证了结果是一个在三维超平面上中的纯四元数。</p>
<h3 id="点乘和叉乘"><a href="#点乘和叉乘" class="headerlink" title="点乘和叉乘"></a>点乘和叉乘</h3><p>点乘（内积）的结果是一个数，反应了两个向量在方向上的相似度，方向相同值越大，反之值越小，范围为-a到a，a就是两者模的乘积。<br>叉乘（外积）的结果是一个向量，以三维举例，模长和两个向量组成的平行四边形的面积相等，方向垂直与两个向量组成的平面，当a在b顺时针方向则向上，反之向下。可以利用这个性质判断物体在左边还是右边，如果外积之后y为正，则a在b的右边，反之在左边，如果a和b在同一直线上，则外积为零向量。<br>叉乘：a×b = （y1z2-z1y2,  z1x2-x1z2, x1y2-y1x2）<br>如果在二维上 a×b = x1y2 - y1x2，看起来是一个数，实际上方向在第三个轴上，这个数的正为正a在b的右边，反之在左边。</p>
<h3 id="如何判断一个点在三角形内"><a href="#如何判断一个点在三角形内" class="headerlink" title="如何判断一个点在三角形内"></a>如何判断一个点在三角形内</h3><p>面积法：<br>如果P点在三角形ABC内，则三角形面积等于：ABP+ACP+BCP的面积<br>求一个三角形的面积可以用叉乘，叉乘的结果可以求两个向量组成的平行四边形面积，三角形的面积是平行四边形的一半，因此通过向量PA，PB，PC就能求出三个三角形面积，AB，AC能求出大三角形面积。</p>
<h3 id="射线和平面求交算法"><a href="#射线和平面求交算法" class="headerlink" title="射线和平面求交算法"></a>射线和平面求交算法</h3><p>垂直于平面的线与射线垂直。</p>
<h3 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h3><p>如果存在一条直线ax+by+c=0，那么点(x0,y0)到直线的距离为：<br>$$<br>d = \frac {|ax_0 + by_0 +c|}{\sqrt{a^2 + b^2}}<br>$$</p>
<h3 id="判断二维凸包"><a href="#判断二维凸包" class="headerlink" title="判断二维凸包"></a>判断二维凸包</h3><p>可以想象在平面中有一些点，这些点的集合为 X，拿一个橡皮圈撑到最大，尝试套住所有的点，待橡皮圈绷紧后，它会成为一个多边形，这个多边形所有顶点组成的集合便为集合 X 的凸包。<br>Gift wrapping算法：</p>
<p>（1） 找到一个一定在凸包中的初始点，比如最左下的点<br>（2） 计算剩下的所有点与初始点正向下方向之间的角度，取最小的角度的点加入凸包<br>（3） 对于最新加入凸包的点，取前一个点指向该点的方向作为初始方向，遍历剩下的点，取剩下的点和该点的连线与初始方向夹角最小的点加入凸包<br>（4） 重复 3，直到找到的下一个点是初始点</p>
<h3 id="碰撞检测GJK算法、"><a href="#碰撞检测GJK算法、" class="headerlink" title="碰撞检测GJK算法、"></a>碰撞检测GJK算法、</h3><p>GJK 算法可以在 O(M+N)的时间复杂度内，检测出碰撞，算法在每次迭代的过程中，都会优先选择靠近原点的方向，因此收敛速度会很快。<br>通俗的讲，GJK 算法就是沿着某个方向，从两个多边形上取相距最远的两个点计算差值；然后将方向取反，再次取两个点计算出差值。如果两个多边形发生碰撞，则这两个差值必然有一个大于 0，一个小于 0。如果不相交，则两个差值是同为正或同为负。</p>
<h3 id="碰撞检测四叉树"><a href="#碰撞检测四叉树" class="headerlink" title="碰撞检测四叉树"></a>碰撞检测四叉树</h3><p>四叉树就是一种优化方法，能够帮助我们对元素按照区域进行划分，减少检测数量。需要说明的是，四叉树只是一种「减少碰撞候选者」的算法，在利用四叉树得到碰撞候选元素后，还需要检测这些候选元素与目标元素是否发生碰撞。<br>假如在我们要在游戏中对 200 个物体进行碰撞检测，按照常规的碰撞检测方式，每帧每个物体都要对其他 199 个物体进行物理碰撞检测，则需要进行 200*199=39800 次检测。这样的检测效率，很容易对低端手机的性能造成一定的影响。</p>
<p>方法：<br>我们把游戏屏幕看做一个区域，不断放置圆点进去。假设我们设定每个区域只能容纳 4 个物体，只要超过这个数量，就分割该区域。如下图，当区域内的圆点数达到 4 个，这个时候再想加入第 5 个，就必须先将当前区域分割为 4 个区域，再将第 5 个放入左上区域。如果物体处在交界的区间内，那么把物体放在上一层次的区域内，不然就放在该层。</p>
<p>步骤：</p>
<ul>
<li>创建四叉树，区域为整个屏幕，并将树保存为全局变量；</li>
<li>插入需要做碰撞检测的目标元素；</li>
<li>检索目标元素的待检测碰撞对象，返回碰撞候选元素组；</li>
<li>清除四叉树中的元素，以方便下次继续检测</li>
</ul>
<h3 id="AABB（轴对称矩形边界框）"><a href="#AABB（轴对称矩形边界框）" class="headerlink" title="AABB（轴对称矩形边界框）"></a>AABB（轴对称矩形边界框）</h3><p>AABB-box 简单点说就是垂直于坐标轴的包围盒，搞过物体识别的标注的童鞋都知道，这种包围盒不会旋转（当物体旋转的时候，就用更大的包围盒去包围它），因此使用起来非常简单。<br>AABB-box 对应的是 OBB-box, OBB-box 会跟着物体的朝向一起旋转，而大小不会改变，相对来说比 AABB-box 更加准确，但是检测碰撞的运算量会比AABB-box 大一点。<br>到采用包围盒之后简化了需要检测碰撞的模型，用其它更加简单的形状去做粗校验，避免采用更复杂的多边形去检测碰撞。</p>
<h3 id="松散四叉树，BVH，BS，KD-树的特性以及适用情况"><a href="#松散四叉树，BVH，BS，KD-树的特性以及适用情况" class="headerlink" title="松散四叉树，BVH，BS，KD 树的特性以及适用情况"></a>松散四叉树，BVH，BS，KD 树的特性以及适用情况</h3><h4 id="松散四叉树"><a href="#松散四叉树" class="headerlink" title="松散四叉树"></a>松散四叉树</h4><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/180560098">https://zhuanlan.zhihu.com/p/180560098</a><br>四叉树是一种将二维空间划分为四个象限的树结构，每个节点可以有最多四个子节点。松散四叉树相比于传统的四叉树在节点分割和合并的策略上有所不同，它在一些情况下可以减少树的深度和节点数量，从而提高查询效率。</p>
<p>松散四叉树的特点是：</p>
<p>节点的子节点不一定都存在。如果某个节点的四个子节点都为空且该节点中存储的对象数量很少，可以考虑将该节点与其相邻的同级节点合并，从而减少树的深度和节点数量。<br>节点的划分和合并策略是动态的。根据对象的插入、删除和移动等操作，动态地进行节点的划分和合并，以保持树的平衡性和性能。</p>
<p>松散四叉树/八叉树中，是指出口边界比入口边界要宽些（虽然各节点的出口边界也会发生部分重叠），从而使节点不容易越过出口边界，减少了物体切换节点的次数。问题在于如何定义出口边界的长度。因为太短会退化成正常四叉树/八叉树，太长又可能会导致节点存储冗余的物体。经过前人的实验表明出口边界长度为入口边界2倍最佳。</p>
<h4 id="层次包围盒-BVH（待完善）"><a href="#层次包围盒-BVH（待完善）" class="headerlink" title="层次包围盒 BVH（待完善）"></a>层次包围盒 BVH（待完善）</h4><p>这部分是目前渲染器中最困难的部分，但是可以是渲染器更加高效，所以我们需要花上一点时间去重构之前的代码。</p>
<p>寻找射线与物体的交点是渲染器主要耗时的地方之一，而且时间消耗随着场景内物体的数量递增。</p>
<p>我们要做的是使用二分法对场景内的物体进行搜索，而不是遍历所有物体。</p>
<h4 id="二叉空间分割-BSP"><a href="#二叉空间分割-BSP" class="headerlink" title="二叉空间分割 BSP"></a>二叉空间分割 BSP</h4><p>BSP（Binary Space Partitioning）是一种二叉空间分割数据结构，用于对三维空间进行分割和表示。它是一种递归的树结构，每个节点表示一个空间分割平面，将空间划分为两个子空间。<br>BSP树的构建过程是通过递归地选择一个空间分割平面，并将空间划分为两个子空间。通常选择的分割平面可以是平面、线段或者点。在构建过程中，根据空间中的物体位置，将物体放置在合适的子空间中。这样，通过不断地划分空间，最终构建出一棵树，其中每个叶子节点表示空间中的一个区域。使 VSD 问题易于解决。</p>
<p>讲到这里，你需要先了解一下为什么分割场景可以奏效：如果你在场景上画条线（对应三维空间里的一个平面），你就可以指出玩家或者摄像机视角在这条线的哪一侧，在这条线另一侧的物体无法遮挡玩家所在一侧的物体。如果多次重复这一操作，该三维场景最终会被分割为多个区域，这并不是对原始场景的改进，只是现在你知道了更多关于场景的不同部分会如何相互阻挡。</p>
<p>用途：</p>
<ol>
<li>空间裁剪（Clipping）：BSP树可以用于剔除不可见的物体或区域，提高图形渲染性能。通过构建BSP树，可以确定哪些物体在视锥体内部，从而避免对视锥体外部的物体进行渲染和处理。</li>
<li>可视性检测（Visibility Determination）：BSP树可以用于确定场景中哪些物体对于特定视点是可见的，从而优化图形渲染过程。通过遍历BSP树，可以快速确定与视点相交的节点和区域，提高渲染效率。</li>
<li>碰撞检测（Collision Detection）：BSP树可以用于检测物体之间的碰撞。通过构建BSP树，可以有效地判断两个物体是否相交，从而进行碰撞检测、物体遮挡检测等。</li>
<li>光线跟踪（Ray Tracing）：BSP树在光线跟踪算法中有重要的应用。通过构建BSP树，可以加速光线和物体之间的相交检测，从而实现高效的光线跟踪渲染。</li>
</ol>
<p>总的来说，BSP树通过对空间进行递归的二叉分割，能够有效地处理复杂的空间关系，提高图形渲染和物体检测的效率。然而，BSP树也有一些限制，例如在处理动态场景时，需要频繁地更新树结构，且构建过程较为复杂。因此，在具体应用中需要根据场景需求和性能要求综合考虑是否使用BSP树或其他的空间分割数据结构。</p>
<p>应用：<br>BSP 适合结构比较紧凑的互相遮挡多的场景<br>fps 室内，portal 系统</p>
<h4 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h4><p>一种特殊形式的 BSP 树（轴对齐的 BSP 树），每一层都在不同的轴，适用于最近的静态目标的查找，构造比较耗时，一般不动态刷新。查询点均落在划分轴上，每次划分前都计算这个块中中间位置的点，穿过这个点进行轴划分</p>
<p>在KD树中，每个节点代表一个数据点，并根据其特征值在某个维度上进行划分。具体划分的方式有多种，常见的有以下两种：</p>
<ol>
<li>坐标轴对齐划分：每个节点按照某个维度上的特征值进行划分，左子树包含小于等于该特征值的点，右子树包含大于该特征值的点。划分的维度会循环选择，例如第一层按照x轴划分，第二层按照y轴划分，以此类推。</li>
<li>中值划分：每个节点选择在某个维度上的中值作为划分值，将小于等于中值的点放入左子树，大于中值的点放入右子树。划分的维度可以通过循环选择，也可以在每个节点中选择方差最大的维度。</li>
</ol>
<p>应用：<br>最近邻静态目标查找，例如上百的单位找最近的建筑，用 kd 树代替遍历+距离判断。</p>
<h4 id="几种结构的比较"><a href="#几种结构的比较" class="headerlink" title="几种结构的比较"></a>几种结构的比较</h4><p>几种结构的比较<br>（1） 四叉树最适合二维数据，例如导航系统中的地图渲染。在这种情况下，它比八叉树更快，因为它可以更好的适应几何形状并保持节点结构较小；如果数据是三维的，则用八叉树和 BVH。<br>（2） BSP 旨在优化大型静态几何体，不适合需要大量动态增加物体的场合中，自带排序属性。<br>（3） BVH 多用于光线追踪（bvh 做 pvs(潜在可视几何)并不算特别有效率。bvh 做线段求交很快）碰撞检测，潜在碰撞集是关键，所以会使用更加优化邻近搜索的侧脸譬如 kdtree 或者 rtree。<br>（4） KD 树是平衡的，很难动态更新；OCTree 比较容易更新。</p>
<h3 id="A-寻路算法"><a href="#A-寻路算法" class="headerlink" title="A*寻路算法"></a>A*寻路算法</h3><p>A*算法的寻路是基于代价作为计算的，它把一个地图划分为一个个节点，我们可以以一个整数坐标作为一个节点当算法探寻到这个节点的时候，会给这个节点一个代价值，这个值由两部分构成，一部分是从起点到现在的点所消耗的代价，可以如果每个节点所消耗的代价是1，那么没走一个代价+1，第二部分是一个预估值，预估了从当前节点到目标节点的距离，这个距离可以用欧式距离或曼哈顿距离来计算。把这两个值相加得到一个总代价，然后把节点放入优先队列中，把这个代价作为优先值。然后我们每次从优先队列中取出优先值最低的元素，然后遍历其周围的节点，计算其代价，然后放进优先队列中，循环往复直到找到目标节点。<br>我们在场景中可以利用四叉树来简化地图简单，或者Unity的导航三角网格。</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">a_star_search</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> start<span class="token punctuation">,</span> goal<span class="token punctuation">)</span><span class="token punctuation">:</span>
  frontier <span class="token operator">=</span> PriorityQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>
  frontier<span class="token punctuation">.</span>put<span class="token punctuation">(</span>start<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  came_from <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>   
  cost_so_far <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># 键为节点，值为代价</span>
  came_from<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> None
  cost_so_far<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>

  <span class="token keyword">while</span> <span class="token operator">not</span> frontier<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    current <span class="token operator">=</span> frontier<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> current <span class="token operator">=</span> goal<span class="token punctuation">:</span>
      <span class="token keyword">break</span>
    <span class="token keyword">for</span> next <span class="token keyword">in</span> graph<span class="token punctuation">.</span>neighbors<span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">:</span>
      next_cost <span class="token operator">=</span> cost_so_far<span class="token punctuation">[</span>current<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
      <span class="token keyword">if</span> next <span class="token operator">not</span> <span class="token keyword">in</span> cost_so_far <span class="token operator">or</span> new_cost <span class="token operator">&lt;</span> cost_so_far<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">:</span>
        cost_so_far<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">=</span> new_cost
        priority <span class="token operator">=</span> new_cost <span class="token operator">+</span> heuristic<span class="token punctuation">(</span>goal<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
        frontier<span class="token punctuation">.</span>put<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">=</span> current
  <span class="token keyword">return</span> came_from<span class="token punctuation">,</span> cost_so_far</code></pre>
<h2 id="图形学（Shader）"><a href="#图形学（Shader）" class="headerlink" title="图形学（Shader）"></a>图形学（Shader）</h2><h2 id="MMORPG项目"><a href="#MMORPG项目" class="headerlink" title="MMORPG项目"></a>MMORPG项目</h2><h3 id="注册登录系统"><a href="#注册登录系统" class="headerlink" title="注册登录系统"></a>注册登录系统</h3><p>保存了账号密码，还有对应的角色ID，角色名字不可是全数字，不能与其他玩家相同。</p>
<h3 id="移动同步"><a href="#移动同步" class="headerlink" title="移动同步"></a>移动同步</h3><p>同步指两个或两个以上随时间变化的量在变化过程中保一定的相对关系。游戏中需要同步的是角色信息，位置、状态。各个客户端的数据应当是同步的。这里使用了基于TCP的状态同步，状态同步有以下特点：</p>
<ol>
<li>消息传输的频率较低</li>
<li>回放还原较难</li>
<li>逻辑在服务器，安全</li>
<li>比较难以进行精确的战斗校验</li>
<li>服务器压力大</li>
<li>断线重连无负担</li>
<li>实现难点在于客户端需要做插值或行为预测等方式优化卡顿体验，调测压力较大</li>
</ol>
<p>帧同步有以下特点：</p>
<ol>
<li>消息传输的频率较高</li>
<li>回放还原容易</li>
<li>逻辑在客户端，难以避免外挂</li>
<li>服务器可以进行完整战斗模拟</li>
<li>服务器只负责转发，压力小</li>
<li>游戏时间越长断线重连越难</li>
<li>难点在于需要规避浮点数的问题，并且逻辑和表现要进行分离，对设计有一定要求。</li>
</ol>
<p>过程：</p>
<ol>
<li>客户端输入：<br>客户端收集玩家的输入操作，例如按键、鼠标点击等。<br>客户端根据输入生成相应的指令或消息，并将其发送给服务器。</li>
<li>服务器接收指令：<br>服务器接收客户端发送的指令或消息。<br>服务器对指令进行验证和解析，确保其合法性和正确性。</li>
<li>服务器更新游戏状态：<br>服务器根据接收到的指令更新游戏状态，例如玩家位置、动作、血量等。<br>服务器执行游戏逻辑，处理碰撞、计算伤害等。</li>
<li>服务器广播状态更新：<br>服务器将更新后的游戏状态广播给所有连接的客户端。<br>服务器使用网络协议将状态信息发送给客户端。</li>
<li>客户端接收状态更新：<br>客户端接收服务器广播的游戏状态更新。<br>客户端根据接收到的状态更新，更新本地的游戏状态。</li>
<li>客户端渲染和表现：<br>客户端根据本地的游戏状态进行渲染和表现，显示最新的游戏画面给玩家。</li>
</ol>
<h3 id="UI系统架构"><a href="#UI系统架构" class="headerlink" title="UI系统架构"></a>UI系统架构</h3><p>UI可以分为静态UI和动态UI<br>静态UI：普通窗口、对话框、信息框<br>动态UI：公告，TIPs、战斗飘字</p>
<p>UIMain：首先，在主场景我们设置了一个UIMain的节点，上面挂着的脚本是常驻内存的，设置为单例类，这个节点下挂了很多在UI界面常驻的UI，例如人物头像，血条，人物的技能栏，聊天系统，背包，任务，坐骑，属性，等按钮。这个主UI是不会销毁的，只会隐藏。<br>UIManager：各个游戏系统的UI，用不到的时候不会加载，管理所有UI的脚本，UI需要在其中注册，并且可以设置这些UI在关闭时销毁或隐藏，然后利用注册的Key调用对应Show和Close方法来实现打开和关闭逻辑。</p>
<p>UIWindow：里面编写了常用的点击事件，并且有不同的关闭方法。使得继承它的UI都拥有基本的功能。</p>
<p>UIMessagerBox：用户用来显示提示，分为只有确定按钮的提示，和确定和取消两种按钮的提示，这个UI显示在界面的最上层。我们可以自由配置信息文章，按钮文字，标题文字。</p>
<h3 id="道具和背包系统架构"><a href="#道具和背包系统架构" class="headerlink" title="道具和背包系统架构"></a>道具和背包系统架构</h3><p>道具一共有几种分类：可使用、可装备、任务物品、材料、通用（可卖钱）<br>道具系统需要的功能：添加道具、删除道具、道具使用、获取道具列表（用于背包）<br>为了便于管理，我们需要一张配置表，配置表上指定了物品的名字，描述，类型，能否使用，购买价格，售出价格，最大堆叠数量等等，这些往往有策划进行配置，程序只需要把这张excel转换为Json，然后读到程序之中即可。</p>
<p>因此，客户端和服务端都需要一个ItemManager、ItemService，ItemService负责双端之间的通信，ItemManager负责添加物品，删除物体等逻辑的处理，不同的地方在于客户端只存在一个ItemManger（单例类），服务器每个角色都配置一个ItemManager。ItemManager收到<br>ItemService传过来的数据，读取配置表的相关数据，对道具进行处理就可以了，处理完成之后保存数据库就可以了。</p>
<p>背包系统是基于道具系统之上开发的功能，具有查看，管理，道具交互的功能，比如说：分页、整理，道具使用、丢弃。背包系统以每个格子作为一个单独的对象，设定了存放物品的种类的数量等，通常来说，对物品进行使用，丢弃等操作的时候，背包需要刷新一下，我们就可以更加特定的顺序，物品堆叠的数量来整理背包。背包的状态改变后把对应的信息储存到数据库中。</p>
<p>除此之外，拼UI也是比较讲究的，关键是运用好ScrollView组件，可以实现背包中上下拖动的功能，然后在Content里面使用Grid Layout Group组件来管理格子，Content里面包含了所有解锁和未解锁的背包格子，使用代码遍历这些格子，然后在配置表中找到对应图片的路径，加载出来，并把父物体设为这些格子就能实现背包的功能了。</p>
<h3 id="商店系统"><a href="#商店系统" class="headerlink" title="商店系统"></a>商店系统</h3><p>商店类型可以分为杂货店，装备店等等，功能主要是展示商品列表，道具购买，一般的商店系统会和NPC系统有一定的联系，比如点击NPC打开商店，所以商店系统需要设定对应的接口给其他系统进行调用。<br>对于商店系统，我们也需要配置一张表，这张表包含了每个商店物品的信息，购买数量等等。购买之后需要和道具与背包联动。</p>
<h3 id="装备系统"><a href="#装备系统" class="headerlink" title="装备系统"></a>装备系统</h3><p>装备其实也是道具的部分，部分信息存储于道具配置表，但是还有一些道具配置表没有的信息，例如增加的力量，智力，敏捷，生命，法力等等，所以我们需要另外一张表存储这些信息。<br>装备的获取和道具一样，不同点在于装备是可以穿戴的，并且会实时改变玩家的属性，这涉及到战斗系统的部分内容。玩家的属性由几部分决定，第一是职业，不同的职业会有不同的初始化属性，第二是等级，等级成长导致属性增加，第三是装备导致的属性改变，这几种属性基本上不会随着时间的流逝而改变，第四种是buff属性，分为增益buff和负面buff，这项属性会随时变动，随着时间的流逝叠加或消失。<br>客户端会管理一个自己身上穿着的装备列表格子，每种装备只能穿戴一件，并且有穿戴要求，服务器管理着每个人身上的装备列表，当穿戴发生改变时客户端发送给服务器做逻辑处理，服务器保存数据库之后返回客户端，客户端表现为外观的改变以及数值的改变。</p>
<h3 id="任务系统"><a href="#任务系统" class="headerlink" title="任务系统"></a>任务系统</h3><p>任务分类可以分为主线和支线任务，任务目标可以分为对话，杀怪，收集，任务奖励分为经验，金币，道具，任务领取对象一般为NPC，任务的交互一般分为查看任务，接受任务，拒绝任务，完成任务。<br>每个人身上的的任务都有几种状态：未接取，已接未完成，已完成未提交，已提交状态，而很多任务又有前置任务，前置任务未完成无法接取这个任务。<br>所以任务系统需要配置这样一个表，规定任务等级，职业，前置任务，任务接取NPC，任务描述，对话，任务目标，奖励等。<br>数据库也需要保存任务列表及其完成状态，分别是已接取，已完成未提交，已提交。在和NPC交互的时候，只显示符合自己条件的，未完成的任务。完成任务后提供对应的奖励，这和NPC系统，道具系统有一定的交互。</p>
<h3 id="好友系统"><a href="#好友系统" class="headerlink" title="好友系统"></a>好友系统</h3><p>在数据库添加好友，对应的ID，等级职业等，并且在好友列表上显示在线装态</p>
<h3 id="组队系统"><a href="#组队系统" class="headerlink" title="组队系统"></a>组队系统</h3><p>需求分析：组队一般用于副本，组队入口可以是聊天，以及好友列表，我们可以邀请在线好友进行组队，并且队长可以踢人，转让队长，队员可以离开队伍。组队信息一般不存储在数据库上，跑在服务器的内存中。服务器内存会维护一个队伍的列表，每个队伍都有其队长。队伍生成后不销毁只重置，防止对象的反复创建销毁。</p>
<h3 id="公会系统"><a href="#公会系统" class="headerlink" title="公会系统"></a>公会系统</h3><p>和组队类似，但是公会系统是保存在数据库中的，并且数据库会储存申请信息以便会长处理，会长可以提拔罢免副会长，会长和副会长都可以通过入会申请，踢出普通成员，队长离开公会会提拔副会长为会长。</p>
<h3 id="聊天系统"><a href="#聊天系统" class="headerlink" title="聊天系统"></a>聊天系统</h3><p>需求分析：聊天分为多种，一种是私聊1对1发送，其他频道聊天有本地、世界、组队、公会。聊天区的交互可以有私聊、加好友，邀请组队。<br>聊天系统使用了Candlelight插件，用于显示聊天文本，支持超链接，并且可以设计对应种类的文字样式，点击超链接触发对应的事件，例如弹出菜单，可以选择私聊，组队，加好友。<br>聊天系统的核心是对应频道的通信，如果是私聊，服务器可以只做转发，如果是频道聊天，服务器需要自己储存一份，然后转发给对应频道的人，如果有人上线了，也需要从频道中获取之前的聊天信息。</p>
<h3 id="坐骑系统"><a href="#坐骑系统" class="headerlink" title="坐骑系统"></a>坐骑系统</h3><p>坐骑没有做Service和Manager，如果很轻量可以把代码放到一起，坐骑可以看作是物品的一种，只是可以从坐骑面板中看到而已。因此我们无需添加额外的协议和数据库，直接利用道具系统、商店系统以及移动同步就能把坐骑系统完成</p>
<h3 id="刷怪系统"><a href="#刷怪系统" class="headerlink" title="刷怪系统"></a>刷怪系统</h3><p>刷怪系统由刷怪规则和刷怪逻辑组成，刷怪规则就是每隔多久在什么地点刷怪，刷怪逻辑对应刷怪的流程，刷怪的种类，等级。我们可以配置一个表定义了每个地图有哪些刷怪点，每个刷怪点有哪些怪物，怪物等级，刷新时间等。然后我们可以通过Unity编辑器脚本来可视化生成对应的刷怪位置信息。刷怪是服务器的事情，客户端只负责表现。</p>
<h3 id="战斗系统"><a href="#战斗系统" class="headerlink" title="战斗系统"></a>战斗系统</h3><p>客户端战斗：客户端执行核心逻辑，服务端验证逻辑，分为数据验证（属性验证）和战斗回放验证，两个人以上比较好验证。<br>服务器战斗：服务器执行核心逻辑，客户端处理表现，这样就不需要验证。<br>每一个战斗都用一场BattleManager来管理，战斗管理可以分为战斗对象管理，战斗状态管理，战斗结算。</p>
<p>在设计战斗系统之前我们需要设计属性模块：<br>属性分为基础属性（初始值、等级成长）、附加属性（装备等）、动态属性（Buff等）。属性分为一级属性和二级属性，一级是力量、智力，敏捷，二级是生命，法力，物理攻击，法术攻击，物理防御法术防御，暴击率等。每次角色生成都会把这些属性计算一次，每一次状态改变时都会重新计算属性。</p>
<p>开始战斗时，由一个单位向另一个单位释放技能。这通知到服务器之后，服务器判断技能是否可以释放（冷却，别的技能释放中，没有MP等释放不了），如果可以释放，发信息给客户端做表现，然后服务器开始进行逻辑计算，在什么时候，对什么范围的敌人产生伤害，叠加buff，并且把buff和伤害信息发送给客户端，客户端表现为伤害跳字，buff特效。发包数量是优化过的，这些信息如果在同一帧内是可以打包发出去，如果同一帧发包过多，可以放在队列中储存，每一帧发送一定量的包出去，使负载得到均衡。<br>技能可以分为瞬发技能，非瞬发技能（有前摇），也可以分为单体技能和范围技能，也可分为子弹技能和非子弹技能，也可分为有持续时间和没有持续时间的技能，技能的释放过程是先经历一个前摇时间，这个前摇时间不可移动，还有一个施法时间，如果移动会取消施法。然后是释放时间，如果技能是一段的话，立刻产生伤害，如果是多段则每隔一段时间产生一次伤害，如果是范围技能，就是每隔一段时间对响应范围内的敌人产生伤害。</p>
<img src="/tianjuehai/2023/04/29/chong-ji-qiu-zhao/2.png" class="">

<h3 id="最有挑战性的bug，怎么解决的"><a href="#最有挑战性的bug，怎么解决的" class="headerlink" title="最有挑战性的bug，怎么解决的"></a>最有挑战性的bug，怎么解决的</h3><ol>
<li>角色死亡释放技能，切换地图后报错，没找到被销毁的物体，反复测试找到原因</li>
</ol>
<h2 id="Xlua框架"><a href="#Xlua框架" class="headerlink" title="Xlua框架"></a>Xlua框架</h2><p>这部分内容具体参考《XLua热更新框架》这篇文章</p>
<h3 id="框架的构成"><a href="#框架的构成" class="headerlink" title="框架的构成"></a>框架的构成</h3><img src="/tianjuehai/2023/04/29/chong-ji-qiu-zhao/3.png" class="">

<p>UIGameLoading：热更新检测模块，检测版本，检测资源，开启下载，并进入游戏主界面<br>AppBoot：启动器模块，初始化音频模块，SDK初始化完毕方法，Lua回调时间列表监听与调用<br>LuaTools：Lua工具类，有网络请求方法，网络请求回调方法，音频播放，等等<br>LuaBehaviour：Lua纽带类，与main.lua通信，定义luaAction，启动lua虚拟机，执行自定义lua资源目录，绑定lua端方法<br>ResourceManager：预制体管理、游戏体管理，图片管理，功能模块管理，lua脚本管理，音频资源管理，字体资源管理，材质贴图管理<br>SystemTool：系统拒绝，引擎碰撞回调，射线回调，输入回调等</p>
<p>ui.lua：业务功能管理模块，功能打开关闭，生成预制体，loading界面控制<br>main.lua：lua主脚本，加载框架模块，打开登录功能，绑定方法接收端<br>net.lua：网络管理模块，设置请求IP，设置session，设置账户，设置请求数量，网络请求响应回调方法，网络请求发送方法<br>list.lua：列表工具，列表创建方法<br>GameMainData：主数据管理模块，引用主数据model，设置主数据，提供数据操作方法<br>event.lua：事件管理模块，包含事件操作方法<br>plugin.lua：插件管理目录，设置插件相关信息<br>public.lua：功能资源管理模块，管理公共方法，管理公共变量<br>tools.lua：工具管理模块，有工具类方法</p>
<p>UIGameLoading会完成资源热更新的工作，然后加载一个挂载AppBoot和LuaBehaviour脚本的空物体，LuaBehaviour一启动就创建一个lua虚拟机，把lua脚本转换为字节码到内存中，调用main.lua正式开始执行lua脚本。<br>我们要将lua脚本的某些函数和LuaBehaviour中的某些函数绑定起来，当做入口：</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">internal</span> <span class="token keyword">static</span> LuaEnv luaEnv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LuaEnv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
LuaEnv<span class="token punctuation">.</span>CustomLoader method <span class="token operator">=</span> CustomLoaderMethod<span class="token punctuation">;</span>
luaEnv<span class="token punctuation">.</span><span class="token function">AddLoader</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>

scriptEnv <span class="token operator">=</span> luaEnv<span class="token punctuation">.</span><span class="token function">NewTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
LuaTable meta <span class="token operator">=</span> luaEnv<span class="token punctuation">.</span><span class="token function">NewTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
meta<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"__index"</span><span class="token punctuation">,</span> luaEnv<span class="token punctuation">.</span>Global<span class="token punctuation">)</span><span class="token punctuation">;</span>
scriptEnv<span class="token punctuation">.</span><span class="token function">SetMetaTable</span><span class="token punctuation">(</span>meta<span class="token punctuation">)</span><span class="token punctuation">;</span>
meta<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

scriptEnv<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"self"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
TextAsset mainText <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token generic-method function">Load<span class="token punctuation">&lt;</span>TextAsset<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"main.lua"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
luaScript_ls <span class="token operator">=</span> mainText<span class="token punctuation">.</span>text<span class="token punctuation">;</span>
luaEnv<span class="token punctuation">.</span><span class="token function">DoString</span><span class="token punctuation">(</span>luaScript_ls<span class="token punctuation">,</span> <span class="token string">"LuaBehaviour"</span><span class="token punctuation">,</span> scriptEnv<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment" spellcheck="true">//绑定方法到lua</span>
Action luaAwake <span class="token operator">=</span> scriptEnv<span class="token punctuation">.</span><span class="token generic-method function">Get<span class="token punctuation">&lt;</span>Action<span class="token punctuation">></span></span><span class="token punctuation">(</span> <span class="token string">"Awake"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
scriptEnv<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span> <span class="token string">"Start"</span><span class="token punctuation">,</span> <span class="token keyword">out</span> luaStart<span class="token punctuation">)</span><span class="token punctuation">;</span>
scriptEnv<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token keyword">out</span> luaUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span>
scriptEnv<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>  <span class="token string">"ondestroy"</span><span class="token punctuation">,</span> <span class="token keyword">out</span> luaOnDestroy<span class="token punctuation">)</span><span class="token punctuation">;</span>
scriptEnv<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"ray"</span><span class="token punctuation">,</span> <span class="token keyword">out</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>
scriptEnv<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"OnTriggerEnter"</span><span class="token punctuation">,</span> <span class="token keyword">out</span> TriggerEnter_<span class="token punctuation">)</span><span class="token punctuation">;</span>
scriptEnv<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"rayF"</span><span class="token punctuation">,</span> <span class="token keyword">out</span> rayF<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<p>main.lua<br>在main.lua中对应着C#绑定的方法：</p>
<pre class=" language-lua"><code class="language-lua">require <span class="token string">'net'</span>  
require <span class="token string">'plugin'</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"tools"</span><span class="token punctuation">)</span>  
require <span class="token string">'list'</span>
require <span class="token string">'event'</span>
require <span class="token string">'GameMainData'</span> 
require <span class="token string">'StaticData/StaticData'</span> 
<span class="token keyword">function</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
   <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"UI/ui_1"</span><span class="token punctuation">)</span>   
   UI<span class="token punctuation">.</span><span class="token function">OpenUI</span><span class="token punctuation">(</span><span class="token string">"loginDemo"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span> 

<span class="token keyword">function</span> <span class="token function">sockerSendMsg</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> 
  Event<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"sockerSendMsg"</span> <span class="token punctuation">,</span> v<span class="token punctuation">)</span> 
<span class="token keyword">end</span> 

<span class="token keyword">function</span> <span class="token function">ray</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span> 
  Event<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"ray"</span> <span class="token punctuation">,</span> x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span> 
<span class="token keyword">end</span> 
<span class="token keyword">function</span> <span class="token function">rayF</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
     Event<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"rayF"</span><span class="token punctuation">,</span>v<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span> 
<span class="token keyword">end</span> 
<span class="token keyword">function</span> <span class="token function">OnTriggerEnter</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
   Event<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"OnTriggerEnter"</span> <span class="token punctuation">,</span> v<span class="token punctuation">)</span> 
<span class="token keyword">end</span> 
<span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    Event<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"updateG"</span> <span class="token punctuation">)</span>
<span class="token keyword">end</span> </code></pre>
<p>而这个框架中的lua部分实现了一个时间系统，在对应的地方监听这个事件即可在 Event.Call的时候调用对应的函数。</p>
<h3 id="框架的使用"><a href="#框架的使用" class="headerlink" title="框架的使用"></a>框架的使用</h3><p>配置文件生成：配置文件由工具生成，从excel生成lua脚本。我们有一个汇总数据的GameMainData的Lua脚本，里面require了所有需要用到的数据模块（model）,例如：require(“Model/DemoPlayerModel”),相当于统一管理数据的地方。</p>
<p>游戏每一个功能我们都可以当成一个模块，可以被封装成一个预制体，例如登录模块，装备模块，人物模块，地图模块：</p>
<ol>
<li>使用一个模块之前，我们需要按照功能将模块封装为预制体，将其存放在Module目录对应的功能目录下，Tag设置为uiComponent。</li>
<li>每个功能模块有两个预制体脚本，一个是逻辑脚本功能（功能名.lua），视图脚本（功能名View.lua），这两个是基于框架设计的，并且由工具生成，生成后再补充内容，这样在多人协作的时候就能保证代码的一致性。</li>
<li>在ui.lua脚本中引用逻辑脚本</li>
<li>一般的逻辑都可以通过lua调用Unity的接口完成，涉及物理引擎的逻辑，可以通过定义一个事件，在C#和lua之间进行通讯，通讯方式和上面的代码一样。<br>lua调用C#的方式：<pre class=" language-lua"><code class="language-lua">Vector3 <span class="token operator">=</span> CS<span class="token punctuation">.</span>UnityEngine<span class="token punctuation">.</span>Vector3
Destroy <span class="token operator">=</span> CS<span class="token punctuation">.</span>UnityEngine<span class="token punctuation">.</span>GameObject<span class="token punctuation">.</span>Destroy</code></pre>
</li>
</ol>
<p>网络请求流程：<br>业务模块请求方法-&gt;Net资源脚本-&gt;Net.lua模块-&gt;LuaTools Http方法-&gt;服务器端-&gt;LuaTools回调方法-&gt;AppBoot delayCall-&gt;Net.lua Receive方法-&gt;Net资源脚本 OnReceive OnResult方法-&gt;业务模块回调处理</p>
<h2 id="逻辑题"><a href="#逻辑题" class="headerlink" title="逻辑题"></a>逻辑题</h2><h3 id="赛马问题"><a href="#赛马问题" class="headerlink" title="赛马问题"></a>赛马问题</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KJ411g78y%E3%80%81">https://www.bilibili.com/video/BV1KJ411g78y、</a></p>
<p>25匹马，5条赛道，不能计时，多少场知道前三名。<br>答案：7场。</p>
<h3 id="两个-10G-的文件，200m-内存，排序"><a href="#两个-10G-的文件，200m-内存，排序" class="headerlink" title="两个 10G 的文件，200m 内存，排序"></a>两个 10G 的文件，200m 内存，排序</h3><p>（1）把 10G 大小的文件拆分成 N 个小文件，每个文件 1M<br>（2）把每个文件拉倒内存排序，可以并行操作，在内存中直接使用快排，然后写入文件<br>（3）对文件做两两合并。</p>
<h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p>主要使用对象：AssetBundle、频繁使用的GameObject<br>管理器：</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PoolManager</span><span class="token punctuation">:</span>MonoBehaviour<span class="token punctuation">{</span>
  Transform m_PoolParent<span class="token punctuation">;</span>

  Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span>PoolBase<span class="token operator">></span> m_Pools <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span>PoolBase<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    m_PoolParent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span><span class="token string">"Pool"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token generic-method function">CreatePool<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">string</span> poolName<span class="token punctuation">,</span> <span class="token keyword">float</span> releaseTime<span class="token punctuation">)</span> <span class="token keyword">where</span> T<span class="token punctuation">:</span>PoolBase<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>m_Pools<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>poolName<span class="token punctuation">,</span> <span class="token keyword">out</span> PoolBase pool<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      GameObject go <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GameObject</span><span class="token punctuation">(</span>poolName<span class="token punctuation">)</span><span class="token punctuation">;</span>
      go<span class="token punctuation">.</span>transform<span class="token punctuation">.</span><span class="token function">SetParent</span><span class="token punctuation">(</span>m_PoolParent<span class="token punctuation">)</span><span class="token punctuation">;</span>
      pool <span class="token operator">=</span> go<span class="token punctuation">.</span><span class="token generic-method function">AddComponent<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      pool<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span>releaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
      m_Pools<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>poolName<span class="token punctuation">,</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">CreateGameObjectPool</span><span class="token punctuation">(</span><span class="token keyword">string</span> poolName<span class="token punctuation">,</span><span class="token keyword">float</span> releaseName<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token generic-method function">CreatePool<span class="token punctuation">&lt;</span>GameObjectPool<span class="token punctuation">></span></span><span class="token punctuation">(</span>poolName<span class="token punctuation">,</span> releaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">CreateAssetPool</span><span class="token punctuation">(</span><span class="token keyword">string</span> poolName<span class="token punctuation">,</span> <span class="token keyword">float</span> realeaseTime<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token generic-method function">CreatePool<span class="token punctuation">&lt;</span>AssetPool<span class="token punctuation">></span></span><span class="token punctuation">(</span>poolName<span class="token punctuation">,</span> releaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> Object <span class="token function">Spawn</span><span class="token punctuation">(</span><span class="token keyword">string</span> poolName<span class="token punctuation">,</span><span class="token keyword">string</span> assetName<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>m_Pools<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>poolName<span class="token punctuation">,</span> <span class="token keyword">out</span> PoolBase pool<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> pool<span class="token punctuation">.</span><span class="token function">Spawn</span><span class="token punctuation">(</span>assetName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// assetName存一个全路径最好</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">UnSpawn</span><span class="token punctuation">(</span><span class="token keyword">string</span> poolName<span class="token punctuation">,</span> <span class="token keyword">string</span> assetName<span class="token punctuation">,</span> Object asset<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>m_Pools<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>poolName<span class="token punctuation">,</span> <span class="token keyword">out</span> PoolBase pool<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      pool<span class="token punctuation">.</span><span class="token function">UnSpawn</span><span class="token punctuation">(</span>assetName<span class="token punctuation">,</span> asset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GameObjectPool</span><span class="token punctuation">:</span>PoolBase<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">override</span> Object <span class="token function">Spawn</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    Object obj <span class="token operator">=</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Spawn</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    GameObject go <span class="token operator">=</span> obj <span class="token keyword">as</span> GameObject<span class="token punctuation">;</span>
    go<span class="token punctuation">.</span><span class="token function">SetActive</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">UnSpawn</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">,</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
    GameObject go <span class="token operator">=</span> obj <span class="token keyword">as</span> GameObject<span class="token punctuation">;</span>
    go<span class="token punctuation">.</span><span class="token function">SetActive</span><span class="token punctuation">(</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    go<span class="token punctuation">.</span>transforn<span class="token punctuation">.</span><span class="token function">SetParent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">UnSpawn</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">foreach</span><span class="token punctuation">(</span>PoolObject item <span class="token keyword">in</span> m_Objects<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Ticks <span class="token operator">-</span> item<span class="token punctuation">.</span>LastUseTime<span class="token punctuation">.</span>Ticks <span class="token operator">>=</span> m_ReleaseTime <span class="token operator">*</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">Destory</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>Object<span class="token punctuation">)</span><span class="token punctuation">;</span>
        m_Objects<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AssetPool</span><span class="token punctuation">:</span>PoolBase<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">override</span> Object <span class="token function">Spawn</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Spawn</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">UnSpawn</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">,</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">UnSpawn</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">foreach</span><span class="token punctuation">(</span>PoolObject item <span class="token keyword">in</span> m_Object<span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Ticks <span class="token operator">-</span> item<span class="token punctuation">.</span>LastUseTIme<span class="token punctuation">.</span>Ticks <span class="token operator">>=</span> m_ReleaseTime <span class="token operator">*</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        Manager<span class="token punctuation">.</span>Resource<span class="token punctuation">.</span><span class="token function">UnloadBundle</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        m_Object<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PoolBase</span><span class="token punctuation">:</span>MonoBehaviour
<span class="token punctuation">{</span>
  <span class="token keyword">protected</span> <span class="token keyword">float</span> m_ReleaseTime<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 单位：毫微秒，1秒=10^7毫微秒</span>
  <span class="token keyword">protected</span> <span class="token keyword">long</span> m_LastReleaseTime <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">protected</span> List<span class="token operator">&lt;</span>PoolObject<span class="token operator">></span> m_Objects<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    m_LastReleaseTime <span class="token operator">=</span> System<span class="token punctuation">.</span>DateTIme<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Ticks<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">float</span> time<span class="token punctuation">)</span><span class="token punctuation">{</span>
    m_ReleaseTime <span class="token operator">=</span> time<span class="token punctuation">;</span>
    m_Object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>PoolObject<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 取出对象</span>
  <span class="token keyword">public</span> virual Object <span class="token function">Spawn</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">foreach</span><span class="token punctuation">(</span>PoolObject po <span class="token keyword">in</span> m_Objects<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>po<span class="token punctuation">.</span>Name <span class="token operator">=</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        m_Objects<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>po<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> po<span class="token punctuation">.</span>Object<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">UnSpawn</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">,</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
    PoolObject po <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PoolObject</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    m_Objects<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>po<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Ticks <span class="token operator">-</span> m_LastReleaseTime <span class="token operator">>=</span> m_ReleaseTime <span class="token operator">*</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      m_LastTeleaseTime <span class="token operator">=</span> System<span class="token punctuation">.</span>DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Ticks<span class="token punctuation">;</span>
      <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PoolObject</span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> Object Object<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">string</span> Name<span class="token punctuation">;</span>
  <span class="token keyword">public</span> System<span class="token punctuation">.</span>DateTime LastUseTime<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token function">PolObject</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">,</span>Object obj<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    Name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    Object <span class="token operator">=</span> obj<span class="token punctuation">;</span>
    LastUseTime <span class="token operator">=</span> System<span class="token punctuation">.</span>DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="对象池的调用时机"><a href="#对象池的调用时机" class="headerlink" title="对象池的调用时机"></a>对象池的调用时机</h3><p>在游戏初始化函数中调用管理器创建对象池：</p>
<pre class=" language-csharp"><code class="language-csharp">Manager<span class="token punctuation">.</span>Pool<span class="token punctuation">.</span><span class="token function">CreateGameObjectPool</span><span class="token punctuation">(</span><span class="token string">"UI"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Manager<span class="token punctuation">.</span>Pool<span class="token punctuation">.</span><span class="token function">CreateGameObjectPool</span><span class="token punctuation">(</span><span class="token string">"Monster"</span><span class="token punctuation">,</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Manager<span class="token punctuation">.</span>Pool<span class="token punctuation">.</span><span class="token function">CreateGameObjectPool</span><span class="token punctuation">(</span><span class="token string">"Effect"</span><span class="token punctuation">,</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Manager<span class="token punctuation">.</span>Pool<span class="token punctuation">.</span><span class="token function">CreateGameObjectPool</span><span class="token punctuation">(</span><span class="token string">"AssetBundle"</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>在UI的Close函数中调用UnSpawn，OpenUI函数中调用Spawn，写一个判断，如果对象池中没有这一类对象，再按照原来的方法生成，这样，Close函数中会自动把新生成的对象纳入对象池。</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">OpenUI</span><span class="token punctuation">(</span><span class="token keyword">string</span> uiName<span class="token punctuation">,</span><span class="token keyword">string</span> <span class="token keyword">group</span><span class="token punctuation">,</span> <span class="token keyword">string</span> luaName<span class="token punctuation">)</span><span class="token punctuation">{</span>
  GameObject ui <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  Transform parent <span class="token operator">=</span> <span class="token function">GetUIGroup</span><span class="token punctuation">(</span><span class="token keyword">group</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">string</span> uiPath <span class="token operator">=</span> PathUtil<span class="token punctuation">.</span><span class="token function">GetUIPath</span><span class="token punctuation">(</span>uiName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Object uiObj <span class="token operator">=</span> Manager<span class="token punctuation">.</span>Pool<span class="token punctuation">.</span><span class="token function">Spawn</span><span class="token punctuation">(</span><span class="token string">"UI"</span><span class="token punctuation">,</span>uiPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>uiObj <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    ui <span class="token operator">=</span> uiObj <span class="token keyword">as</span> GameObject<span class="token punctuation">;</span>
    UILogin uiLogic <span class="token operator">=</span> ui<span class="token punctuation">.</span><span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>UILogic<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    uiLogic<span class="token punctuation">.</span><span class="token function">OnOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ui<span class="token punctuation">.</span>transform<span class="token punctuation">.</span><span class="token function">SetParent</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  Manager<span class="token punctuation">.</span>Resource<span class="token punctuation">.</span><span class="token function">LoadUI</span><span class="token punctuation">(</span>uiName<span class="token punctuation">,</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>
  <span class="token punctuation">{</span>
    ui <span class="token operator">=</span> <span class="token function">Instantiate</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token keyword">as</span> GameObject<span class="token punctuation">;</span>
    <span class="token operator">--</span>snip<span class="token operator">--</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token operator">--</span>snip<span class="token operator">--</span>
<span class="token punctuation">)</span></code></pre>
<p>在决定要不要卸载AssetBundle的时候，可以设一个AssetData,每有一个资源引用Bundle的时候就给AssetData的Count加1(从对象池拿或加载Bundle)，资源被销毁的时候减1，当Count等于0放入对象池，一段时间不变就卸载AssetBundle</p>
<h2 id="UI架构设计"><a href="#UI架构设计" class="headerlink" title="UI架构设计"></a>UI架构设计</h2><img src="/tianjuehai/2023/04/29/chong-ji-qiu-zhao/1.png" class="">
<p>UI层级管理：<br>分层（从底到上）：场景UI、主界面UI、普通UI（窗口）、信息UI（广播）、提示窗口、加载界面</p>
<p>工具：资源后处理工具、资源去重校验工具、UI编辑器、UI配置表、脚本自动生成工具</p>
<h2 id="配置表架构设计"><a href="#配置表架构设计" class="headerlink" title="配置表架构设计"></a>配置表架构设计</h2><p>配置表是用来灵活调整游戏表现数据的储存文件，可以是Excel文件<br>期待：在机制上避免篡改，能提供配置数据再封装入口，使用简单，不占用过多内存，有错误快速响应。<br>在游戏的每个阶段需要使用的配置表的数据都不一样，我们不用一次性把所有配置数据加载进来，防止占用过多内存。</p>
<h2 id="客户端如何跟服务器对接"><a href="#客户端如何跟服务器对接" class="headerlink" title="客户端如何跟服务器对接"></a>客户端如何跟服务器对接</h2><ol>
<li>编写客户端Socket程序，连接服务器，做好连接管理</li>
<li>与服务器开发人员确定协议的格式</li>
<li>与服务器确定数据内容的编码方式</li>
<li>做一个服务器代码模块与每个服务器进行通讯</li>
</ol>
<h2 id="如何找游戏创意和扒资源"><a href="#如何找游戏创意和扒资源" class="headerlink" title="如何找游戏创意和扒资源"></a>如何找游戏创意和扒资源</h2><ol>
<li>我们要学会从不同的平台找好的创意移植</li>
<li>推荐数据平台：七麦数据，可以参考上面各个排行榜上的数据，找到别人不错的创意</li>
<li>确定游戏引擎，通过网络获取游戏的apk文件，或通过iturns获取IOS的ipa文件。这两个文件本质上是zip压缩包，可以直接解压，根据资源结构可以确定引擎。通过lib文件夹中的文件名确定。</li>
<li>安装资源解包工具：AssetStudio（github找）。如果游戏用Unity开发，用工具打开assets-&gt;bin。点击Model-&gt;Export All Objects导出模型。Export-&gt;All Assets导出所有资源。这两个要分开导出。</li>
<li>这些资源包括模型，动画，贴图，甚至shader，音效。我们可以通过这些资源逐步积累自己的资源库。</li>
</ol>
<h2 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h2><ol>
<li><p>自我介绍</p>
</li>
<li><p>是什么让你选择游戏行业</p>
</li>
<li><p>项目中最有成就感的事</p>
</li>
<li><p>为什么投我们公司</p>
</li>
<li><p>职业规划是什么样的</p>
</li>
<li><p>对加班的看法</p>
</li>
<li><p>自己有什么缺点</p>
</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/tianjuehai/about" rel="external nofollow noreferrer">微笑紫瞳星</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://tianjuehai.github.io/tianjuehai/2023/04/29/chong-ji-qiu-zhao/">https://tianjuehai.github.io/tianjuehai/2023/04/29/chong-ji-qiu-zhao/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/tianjuehai/about" target="_blank">微笑紫瞳星</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tianjuehai/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">
                                    <span class="chip bg-color">游戏开发</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/tianjuehai/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/tianjuehai/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">您的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/tianjuehai/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/tianjuehai/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/tianjuehai/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/tianjuehai/libs/valine/av-min.js"></script>
<script src="/tianjuehai/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'bpzS5Q9Q9zMl4doyyDGqIqqq-gzGzoHsz',
        appKey: 'M0IfLJW2G1dCMyLTb90tFxT8',
        notify: 'true' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '请畅所欲言'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/tianjuehai/2023/05/20/kua-yin-qing-ta-shader/">
                    <div class="card-image">
                        
                        
                        <img src="/tianjuehai/medias/featureimages/7.jpg" class="responsive-img" alt="跨引擎TA Shader">
                        
                        <span class="card-title">跨引擎TA Shader</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-05-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/tianjuehai/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" class="post-category">
                                    游戏开发
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tianjuehai/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">
                        <span class="chip bg-color">游戏开发</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/tianjuehai/2023/04/18/ml-agents-yu-zi-ji-de-qiang-hua-xue-xi-suan-fa-tong-xun-ppo-pian/">
                    <div class="card-image">
                        
                        
                        <img src="/tianjuehai/medias/featureimages/12.jpg" class="responsive-img" alt="ML-Agents与自己的强化学习算法通讯——PPO篇">
                        
                        <span class="card-title">ML-Agents与自己的强化学习算法通讯——PPO篇</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-04-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/tianjuehai/categories/Unity%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    Unity强化学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tianjuehai/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/">
                        <span class="chip bg-color">强化学习</span>
                    </a>
                    
                    <a href="/tianjuehai/tags/ML-Agents/">
                        <span class="chip bg-color">ML-Agents</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('50')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 微笑紫瞳星<br />'
            + '文章作者: 微笑紫瞳星<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处，谢谢啦~';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/tianjuehai/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/tianjuehai/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/tianjuehai/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/tianjuehai/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/tianjuehai/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/tianjuehai/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="playlist"
                   id="8075110837"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.35'
                   list-folded='false'
        >
        </meting-js>
    </div>
</div>

<script src="/tianjuehai/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2023</span>
            
            <span id="year">2021</span>
            <a href="/tianjuehai/about" target="_blank">微笑紫瞳星</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">414.6k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "1";
                    var startDate = "9";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "11";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:1121452406@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1121452406" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1121452406" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://blog.csdn.net/tianjuewudi" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://blog.csdn.net/tianjuewudi" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/tianjuehai/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/tianjuehai/libs/materialize/materialize.min.js"></script>
    <script src="/tianjuehai/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/tianjuehai/libs/aos/aos.js"></script>
    <script src="/tianjuehai/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/tianjuehai/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/tianjuehai/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/tianjuehai/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/tianjuehai/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/tianjuehai/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/tianjuehai/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/tianjuehai/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/tianjuehai/live2dw/assets/z16.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>

</html>
